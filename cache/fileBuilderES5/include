function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

fcf.module({
  name: "fcf:NRender/NDetails/Helper.js",
  module: function module() {
    function setArg(a_taskInfo, a_argName, a_value) {
      var normPath = fcf.normalizeObjectAddress(a_argName);
      var ptr = fcf.resolveEx(a_taskInfo.args, normPath, true);
      ptr.object[ptr.key] = a_value;
      delete a_taskInfo.srcArgs[normPath];
      a_taskInfo.processedArgs[normPath] = true;
    }

    return {
      appendChildInfo: function appendChildInfo(a_dstArgs, a_srcArgs, a_chlidInfo) {
        if (!a_chlidInfo || !a_chlidInfo.childs) return;
        if (!a_srcArgs) return;

        if (a_chlidInfo.childs[a_srcArgs.fcfCP]) {
          fcf.append(a_dstArgs, a_chlidInfo.childs[a_srcArgs.fcfCP].args);
          a_dstArgs.fcfChildsArgs = a_chlidInfo.childs[a_srcArgs.fcfCP];
        }
      },
      callHook: function callHook(a_template, a_name, a_taskInfo) {
        if (!a_template.hooks || !a_template.hooks[a_name]) return;
        fcf.setContext(a_taskInfo.context);

        if (typeof a_template.hooks[a_name] == "function") {
          var result = a_template.hooks[a_name].call(a_template.hooks, a_taskInfo);

          if (typeof Promise !== "undefined" && result instanceof Promise || result instanceof fcf.Actions) {
            a_taskInfo.actions.exec(function (a_act) {
              result.then(function (result) {
                a_act.complete();
              })["catch"](function (a_error) {
                a_act.error(a_error);
              });
            });
          }
        }
      },
      callHookBeforeArgument: function callHookBeforeArgument(a_template, a_argName, a_taskInfo) {
        if (!a_template.hooks || !a_template.hooks.hooksBeforeArgument || !a_template.hooks.hooksBeforeArgument[a_argName]) return;
        fcf.setContext(a_taskInfo.context);

        if (a_template.hooks || typeof a_template.hooks.hooksBeforeArgument[a_argName] == "function") {
          var result = a_template.hooks.hooksBeforeArgument[a_argName].call(a_template.hooks, a_taskInfo);

          if (typeof Promise !== "undefined" && result instanceof Promise || result instanceof fcf.Actions) {
            a_taskInfo.actions.exec(function (a_act) {
              result.then(function (result) {
                //setArg(a_taskInfo, a_argName, result);
                a_act.complete();
              })["catch"](function (a_error) {
                a_act.error(a_error);
              });
            });
          } else if (result !== undefined) {
            setArg(a_taskInfo, a_argName, result);
          }
        }
      },
      callHookAfterArgument: function callHookAfterArgument(a_template, a_argName, a_taskInfo) {
        if (!a_template.hooks || !a_template.hooks.hooksAfterArgument || !a_template.hooks.hooksAfterArgument[a_argName]) return;
        fcf.setContext(a_taskInfo.context);

        if (a_template.hooks || typeof a_template.hooks.hooksAfterArgument[a_argName] == "function") {
          var result = a_template.hooks.hooksAfterArgument[a_argName].call(a_template.hooks, a_taskInfo);

          if (typeof Promise !== "undefined" && result instanceof Promise || result instanceof fcf.Actions) {
            a_taskInfo.actions.exec(function (a_act) {
              result.then(function (result) {
                //setArg(a_taskInfo, a_argName, result);
                a_act.complete();
              })["catch"](function (a_error) {
                a_act.error(a_error);
              });
            });
          } else if (result !== undefined) {
            setArg(a_taskInfo, a_argName, result);
          }
        }
      },
      callHookProgramableArgument: function callHookProgramableArgument(a_template, a_argName, a_taskInfo) {
        if (!a_template.hooks || !a_template.hooks.hooksProgramableArgument || !a_template.hooks.hooksProgramableArgument[a_argName]) return;
        fcf.setContext(a_taskInfo.context);

        if (typeof a_template.hooks.hooksProgramableArgument[a_argName] == "function") {
          var result = a_template.hooks.hooksProgramableArgument[a_argName].call(a_template.hooks, a_taskInfo);

          if (typeof Promise !== "undefined" && result instanceof Promise || result instanceof fcf.Actions) {
            a_taskInfo.actions.exec(function (a_act) {
              result.then(function (result) {
                setArg(a_taskInfo, a_argName, result);
                a_act.complete();
              })["catch"](function (a_error) {
                a_act.error(a_error);
              });
            });
          } else if (result !== undefined) {
            setArg(a_taskInfo, a_argName, result);
          }
        }
      }
    };
  }
});
fcf.module({
  name: "fcf:NRender/TaskInfo.js",
  dependencies: ["fcf:NRender/NDetails/Helper.js"],
  module: function module(helper) {
    var NRender = fcf.prepareObject(fcf, "NRender");
    /**
    * @class fcf::NRender::TaskInfo
    * @brief Класс задачи рендеринга шаблона
    **/

    NRender.TaskInfo = function (a_options) {
      var self = this;
      fcf.append(this, a_options);
      this._callMap = {};
      /**
      * @var object args;
      *lng_en @brief The resulting template arguments
      *lng_ru @brief Результирующие аргументы шаблона
      **/

      /**
      * @var fcf::NRender::Render render
      *lng_en @brief Render object
      *lng_ru @brief Объект рендера
      **/

      /**
      * @var object srcArgs
      *lng_en @brief Description of template arguments waiting to be build
      *lng_ru @brief Описание аргументов шаблона ожидающие сборки
      **/

      /**
      * @var fcf::Actions actions
      *lng_ru @brief Объект отложенных вызовов функций
      **/

      /**
      * @var fcf::RouteInfo route
      *lng_en @brief The object of the description of the current route
      *lng_ru @brief Объект описания текущего маршрута
      **/

      /**
      * @var string templatePath
      *lng_en @brief Template address
      *lng_ru @brief Адрес шаблона
      **/

      /**
      * @fn void setArg(string a_path, mixed a_value)
      *
      *lng_en @brief To set a variable of the template used in the hooks.
      *lng_en @brief After calling this method, the a_path argument will not be automatically assembled
      *lng_en @param string a_path The path/filename argument
      *lng_en @param mixed a_value New value
      *
      *lng_ru @brief Установить переменную шаблона, используется в хуках.
      *lng_ru @brief После вызова данного метода автоматическая сборка аргумента a_path выполняться не будет
      *lng_ru @param string a_path Путь/имя аргумента
      *lng_ru @param mixed a_value Устанавливаемое значение
      **/

      this.setArg = function (a_path, a_value) {
        var normPath = fcf.normalizeObjectAddress(a_path);

        this.owner._callHookBeforeArgument(this, normPath);

        var ptr = fcf.resolveEx(this.args, a_path, true);
        ptr.object[ptr.key] = a_value;
        delete this.srcArgs[normPath];
        this.processedArgs[normPath] = true;

        this.owner._callHookAfterArgument(this, normPath);
      };
      /**
      * void render(object a_options)
      *lng_en @brief performs rendering of the template
      *lng_en   - string template Path to the template
      *lng_en   - string args     Template arguments
      *lng_en   - function onResult(a_error, a_template)
      *
      *lng_ru @brief выполняет рендер шаблона
      *lng_ru   - string template Путь к шаблону
      *lng_ru   - string args     Аргументы шаблона
      *lng_ru   - function onResult(a_error, a_template)
      **/


      this.render = function (a_options) {
        var fcfCP = this._getCallPosition();

        var inheritArgs = {};
        helper.appendChildInfo(inheritArgs, {
          fcfCP: fcfCP
        }, this.args.fcfChildsArgs);
        var args = fcf.append({}, a_options.args, inheritArgs, {
          fcfParent: this.args.fcfId,
          fcfCP: fcfCP
        });
        return this._render.render({
          theme: this.state.theme,
          template: a_options.template,
          args: args,
          state: this.state,
          request: this.request,
          reqursion: true,
          onResult: a_options.onResult
        }).then(function (a_template) {
          delete a_template.state;
        });
      };

      this._getCallPosition = function () {
        var stackArr = new Error().stack.split("\n");
        var strInfo = fcf.trim(stackArr[0].indexOf(":") == -1 ? stackArr[3] : stackArr[2], [" ", ")"]);
        var callPostition = "";
        var dc = 0;

        if (strInfo.length) {
          this._callMap;
          var charCode0 = "0".charCodeAt(0);
          var charCode9 = "9".charCodeAt(0);

          for (var i = strInfo.length - 1; i >= 0; --i) {
            var charCode = strInfo.charCodeAt(i);
            if (charCode >= charCode0 && charCode <= charCode9) continue;
            ++dc;

            if (dc >= 2) {
              callPostition = strInfo.substr(i + 1);
              break;
            }
          }
        }

        var cp = "hook:" + callPostition;
        if (!(cp in this._callMap)) this._callMap[cp] = 0;
        cp += "-" + ++this._callMap[cp];
        return cp;
      };
    };

    return NRender.TaskInfo;
  }
});
fcf.module({
  name: "fcf:NFSQL/NFilter/Filter.js",
  dependencies: [],
  module: function module() {
    var NFilter = fcf.prepareObject(fcf, "NFSQL.NFilter");
    NFilter._filters = {};

    NFilter.getFilter = function (a_type) {
      if (a_type in NFilter._filters) {
        return NFilter._filters[a_type].filter;
      } else {
        return NFilter._defaultFilter;
      }
    };

    NFilter.Filter = function (a_options) {
      var self = this;
      this._type = a_options ? a_options.type : {
        type: "text"
      };
      this.comparisons = {};
      this.enableOrder = true;

      this.validate = function (a_description, a_dstErrors) {};

      this.friendly = function (a_view, a_value) {
        return a_value.toString();
      };

      this.availableComparison = function (a_operation, a_mode) {
        if (this.comparisons[a_mode]) return fcf.find(this.comparisons[a_mode], a_operation) != undefined;else if (this.comparisons["*"]) return fcf.find(this.comparisons["*"], a_operation) != undefined;else return false;
      };

      this.comparison = function (a_cmpType, a_left, a_right) {
        switch (a_cmpType) {
          case "=":
            return a_left == a_right;

          case "<":
            return a_left < a_right;

          case ">":
            return a_left > a_right;

          case "<=":
            return a_left <= a_right;

          case ">=":
            return a_left >= a_right;

          case "like":
            var search = fcf.replaceAll(a_right, "%", ".*");
            var re = new RegExp(search, "gi");
            return fcf.str(a_left).search(re) != -1;
        }

        ;
      };

      this.getRealFields = function (a_projection, a_fieldAlias) {
        var rf = fcf.clone(a_projection.mapFields[a_fieldAlias]);
        if (rf.alias == a_projection.key) rf.primary = true;
        return [rf];
      };

      this.equalRealFields = function (a_left, a_right) {
        var res = a_left.field == a_right.field && a_left.type == a_right.type && a_left.min == a_right.min && a_left.max == a_right.max;

        if (!a_left.primary && !a_right.primary) {
          var leftNotNull = !!a_left.notEmpty || !!a_left.notNull;
          var rightNotNull = !!a_right.notEmpty || !!a_right.notNull;
          res &= leftNotNull == rightNotNull;
          res &= !!a_left.unique == !!a_right.unique;
        }

        return !!res;
      };

      this.getDependences = function (a_projection, a_fieldAliasOrType) {
        // if (typeof a_projection === "string")
        //   a_projection = fcf.getProjection(a_projection);
        // a_fieldAliasOrType = typeof a_fieldAliasOrType === "object" ? a_fieldAliasOrType.type : a_fieldAliasOrType;
        return [];
      };

      this.checkStructure = function (a_projection, a_field) {};

      this.validate = function (a_description, a_dstErrors) {};

      this.processOutputField = function (a_taskInfo, a_info) {};

      this.processWhereField = function (a_taskInfo, a_info) {};

      this.processUpdateField = function (a_taskInfo, a_info) {};

      this.processInsertField = function (a_taskInfo, a_info) {};

      this.processDeleteField = function (a_taskInfo, a_info) {};
    };

    NFilter._defaultFilter = new NFilter.Filter();
    return NFilter.Filter;
  }
});
fcf.module({
  name: "fcf:NServer/PackageHandler.js",
  dependencies: [],
  module: function module() {
    var NServer = fcf.prepareObject(fcf, "NServer");

    NServer.PackageHandler = function () {
      this.initialize = function () {};

      this.install = function (a_cb) {};
    };

    return NServer.PackageHandler;
  }
});

if (fcf.isServer()) {
  var modPath = require('path');

  var modFs = require('fs');
}

fcf.addException("ERROR_PACKAGE_NOT_FOUND", "Package '${{1}}$' was not found");
fcf.module({
  name: "fcf:NServer/NDetails/Package.js",
  dependencies: ["fcf:NFSQL/NFilter/Filter.js", "fcf:NServer/PackageHandler.js"],
  module: function module(Filter, DefaultPackageHandler) {
    var NDetails = fcf.prepareObject(fcf, "NServer.NDetails");
    var firstDBQueryErrorSkip = true;

    NDetails.Package = function (a_settings) {
      /**
      * @constructor
      * @param a_settings
      *         - obejct actions
      *         - string package
      *         - array  sources
      *         - array  extension
      *         - object info optional
      *         - string [optional] modPrefix
      **/
      var self = this;
      this._info = {
        html: {
          include: {}
        }
      };
      this._packageName = a_settings["package"];
      this._dependecies = [];

      if (!fcf.empty(a_settings.info)) {
        fcf.append(this._info, a_settings.info);
      }

      this.getInfo = function () {
        return this._info;
      };

      this.getName = function () {
        return this._packageName;
      };

      this.initialize = function () {
        var self = this;
        var packageData = undefined;
        var reverseProjections = [];
        var installModules = [];
        var packageHandler = undefined;
        var clModules = [];
        var clTypes = [];
        var clFunctionsModules = [];
        var clFunctionsTypes = [];
        var dirPack = undefined;
        var modName = undefined;
        var packFilePath = undefined;
        if (fcf.application.getPackages()[a_settings["package"]]) return fcf.actions();
        return fcf.actions().append(function (a_act) {
          packFilePath = self._findPackagePath(a_settings.sources, a_settings["package"] + "." + a_settings.extension);
          if (!packFilePath) throw new fcf.Exception("ERROR_PACKAGE_NOT_FOUND", [a_settings["package"]]);
          dirPack = modPath.dirname(packFilePath);
          modName = a_settings["package"];
          if (a_settings.modPrefix) modName = a_settings.modPrefix + modName.charAt(0).toUpperCase() + modName.substr(1);
          self._packageName = modName;
          var urlPack = "fcfpackages/" + modName;
          fcf.addModule(modName, dirPack, urlPack);
          fcf.load({
            path: packFilePath,
            onResult: function onResult(a_error, a_data) {
              if (a_error) {
                a_act.error(a_error);
                return;
              }

              packageData = fcf.scriptExecutor.parse(a_data, {}, packFilePath, 0);
              a_act.complete();
            }
          });
        }).append(function (a_act) {
          new fcf.Actions({
            onError: a_act
          }).each(packageData.dependencies, function (a_subact, a_key, a_dependencies) {
            var pack = new NDetails.Package({
              application: a_settings.application,
              configuration: a_settings.configuration,
              package: a_dependencies,
              sources: a_settings.sources,
              extension: a_settings.extension
            });
            fcf.actions(pack.initialize()).then(function () {
              a_settings.application.appendPackage(pack);
              a_subact.complete();
            })["catch"](function (a_error) {
              a_subact.error(a_error);
            });
          }).execAC(function () {
            a_act.complete();
          });
        }).append(function (a_act) {
          try {
            self._mergeOptions(packageData);

            if (a_settings.configuration !== false) {
              a_settings.configuration.appendPackageInfo(a_settings["package"], packageData, self.isTheme);
            } // append  template aliases


            if (typeof packageData.aliases === "object") for (k in packageData.aliases) {
              fcf.application.appendTemplateAlias(k, packageData.aliases[k]);
            } // append  template views

            if (typeof packageData.views === "object") for (k in packageData.views) {
              fcf.application.appendViewAlias(k, packageData.views[k]);
            } // append  template filters

            if (typeof packageData.filters === "object") {
              var modules = [];
              var types = [];

              for (type in packageData.filters) {
                modules.push(packageData.filters[type]);
                types.push(type);
              }

              clModules = modules;
              clTypes = types;
            } // append  template FSQL functions


            if (typeof packageData.functions === "object") {
              var modules = [];
              var types = [];

              for (type in packageData.functions) {
                modules.push(packageData.functions[type]);
                types.push(type);
              }

              clFunctionsModules = modules;
              clFunctionsTypes = types;
            }

            if (Array.isArray(packageData.publicFileDirectories)) {
              for (var i = 0; i < packageData.publicFileDirectories.length; ++i) {
                if (typeof packageData.publicFileDirectories[i] !== "object") continue;
                var relativeUrl = packageData.publicFileDirectories[i].relativeUrl;
                var path = packageData.publicFileDirectories[i].path;
                var sourcePath = "";

                if (path.indexOf("@") !== -1) {
                  sourcePath = path;
                } else if (path.indexOf(":") === -1) {
                  sourcePath = modName + ":" + path;
                } else {
                  sourcePath = path;
                }

                relativeUrl = fcf.empty(relativeUrl) ? path : relativeUrl;
                var route = "fcfpackages/" + modName + (fcf.empty(relativeUrl) ? "" : "/" + relativeUrl) + "/*";
                fcf.application.getRouter().append([{
                  uri: fcf.empty(relativeUrl) ? "fcfpackages/" + modName + "/" + packageData.publicFileDirectories[i].path + "/*" : "fcfpackages/" + modName + "/" + relativeUrl + "/*",
                  controller: "fcf:NServer/NControllers/File.js",
                  source: sourcePath
                }]);
              }
            }

            fcf.application.getRouter().append([{
              uri: "fcfpackages/" + modName + "/" + modName + "." + a_settings.extension,
              controller: "fcf:NServer/NControllers/File.js",
              source: modName + ":" + modName + "." + a_settings.extension
            }]);

            if (Array.isArray(packageData.publicFiles)) {
              for (var i = 0; i < packageData.publicFiles.length; ++i) {
                if (typeof packageData.publicFiles[i] !== "object") continue;
                var relativeUrl = packageData.publicFiles[i].relativeUrl;
                fcf.application.getRouter().append([{
                  uri: fcf.empty(relativeUrl) ? "fcfpackages/" + modName + "/" + packageData.publicFiles[i].path : "fcfpackages/" + modName + "/" + relativeUrl + "",
                  controller: "fcf:NServer/NControllers/File.js",
                  source: modName + ":" + packageData.publicFiles[i].path
                }]);
              }
            }

            if (Array.isArray(packageData.routers)) {
              for (var i = 0; i < packageData.routers.length; ++i) {
                if (typeof packageData.routers[i] !== "object") continue;
                fcf.application.getRouter().append([packageData.routers[i]]);
              }
            }

            var projectionFiles = [];

            if (Array.isArray(packageData.projectionDirectories) && !fcf.empty(packageData.projectionDirectories)) {
              var clReadDirectory = function clReadDirectory(a_path) {
                a_path = a_path.indexOf("/") == 0 ? a_path : a_path.indexOf(":") == -1 ? self._packageName + ":" + a_path : a_path;
                a_path = fcf.getPath(a_path);
                var files = modFs.readdirSync(a_path);

                for (var key in files) {
                  var fpath = a_path + "/" + files[key];
                  var fstat = undefined;

                  try {
                    fstat = modFs.statSync(fpath);
                  } catch (e) {
                    continue;
                  }

                  if (fstat.isDirectory()) {
                    clReadDirectory(fpath);
                  } else {
                    if (fcf.getExtension(fpath) == "projection") projectionFiles.push(fpath);
                  }
                }
              };

              for (var _i = 0; _i < packageData.projectionDirectories.length; ++_i) {
                clReadDirectory(packageData.projectionDirectories[_i]);
              }
            }

            if (Array.isArray(packageData.projections) && !fcf.empty(packageData.projections)) {
              var projections = [];
              fcf.each(packageData.projections, function (a_key, a_path) {
                a_path = a_path.indexOf("/") == 0 ? a_path : a_path.indexOf(":") == -1 ? self._packageName + ":" + a_path : a_path;
                projections.push(a_path);
              });
              fcf.append(projectionFiles, projections);
            }

            if (!fcf.empty(projectionFiles)) fcf.application.getProjections().loadFromFiles(projectionFiles);
            fcf.each(fcf.application.getProjections().getProjections(), function (a_alias, a_projection) {
              if (a_projection.dbSync) reverseProjections.push(a_projection);
            });
          } catch (except) {
            a_act.error(except);
            return;
          }

          a_act.complete();
        }).append(function (a_act) {
          if (!fcf.empty(clModules)) {
            fcf.require(clModules, function () {
              for (var i = 0; i < clTypes.length; ++i) {
                var constr = fcf.getModule(clModules[i]).result;
                fcf.NDetails._filters[clTypes[i]] = new constr();
              }

              a_act.complete();
            });
          } else {
            a_act.complete();
          }
        }).exec(function (a_act) {
          if (fcf.application.getSettings().disableUpdateProjection) {
            a_act.complete();
            return;
          }

          fcf.require(["fcf:NFSQL/NDetails/DBBuilder.js"], function (DBBuilder) {
            var dbBuilder = new DBBuilder(fcf.application.getStorage(), reverseProjections);
            dbBuilder.build().then(function () {
              a_act.complete();
            })["catch"](function (e) {
              a_act.error(e);
            });
          });
        }).append(function (a_act) {
          if (!fcf.empty(clFunctionsModules)) {
            fcf.require(clFunctionsModules, function () {
              fcf.each(clFunctionsTypes, function (a_key, a_type) {
                fcf.NFSQL.NFunction.setFunction(a_type, fcf.getModule(clFunctionsModules[a_key]));
              });
              a_act.complete();
            });
          } else {
            a_act.complete();
          }
        }).append(function (a_act) {
          var options = {
            hideErrors: ["ER_NO_SUCH_TABLE", "ERROR_MEMDB_TABLE_NOT_EXISTS"]
          };
          firstDBQueryErrorSkip = false;
          fcf.application.selectSystemVariables("fcf:installModules", options, function (a_error, a_variables) {
            if (a_error) {
              a_act.complete();
              return;
            }

            installModules = Array.isArray(a_variables["fcf:installModules"]) ? a_variables["fcf:installModules"] : [];
            a_act.complete();
          });
        }).append(function (a_act) {
          var dirPack = modPath.dirname(packFilePath);
          var modHandlerName = modName;
          if (modName == "fcf") modHandlerName = "fcfModule";
          var isModuleExist = modFs.existsSync(fcf.getPath(modName + ":" + modName + ".js", true));
          fcf.requireEx([modName + ":" + modHandlerName + ".js"], {
            showError: false
          }, function (a_error, PackageHandler) {
            if (isModuleExist && a_error) {
              console.error(a_error, PackageHandler);
            }

            PackageHandler = PackageHandler ? PackageHandler : DefaultPackageHandler;
            packageHandler = new PackageHandler();

            if (!fcf.application.getSettings().disableSys && fcf.find(installModules, modName) === undefined) {
              fcf.log.log("FCF", "Installing package " + modName + "...");
              fcf.actions(packageHandler.install()).then(function () {
                fcf.log.log("FCF", "Installing package " + modName + " is completed");
                installModules.push(modName);
                fcf.application.updateSystemVariables({
                  "fcf:installModules": installModules
                }, function (a_error) {
                  if (a_error) {
                    fcf.log.err("FCF", a_error);
                  }

                  a_act.complete();
                });
              })["catch"](function (a_error) {
                a_act.error(a_error);
              });
            } else {
              a_act.complete();
            }
          });
        }).append(function (a_act) {
          if (!packageHandler) {
            a_act.complete();
            return;
          }

          fcf.actions(packageHandler.initialize()).then(function () {
            a_act.complete();
          })["catch"](function (a_error) {
            a_act.error(a_error);
          });
        });
      };

      this._mergeOptions = function (a_data) {
        for (var key in a_data) {
          if (key == "publicFileDirectories") {
            if (!this._info[key]) this._info[key] = {};
            fcf.append(this._info[key], a_data[key]);
          } else if (key == "html") {
            if (!a_data[key].include) continue;
            if (!this._info[key]) this._info[key] = {};
            if (!this._info[key].include) this._info[key].include = {};
            fcf.append(this._info[key], a_data[key]);
          } else if (key == "aliases") {
            if (!this._info[key]) this._info[key] = {};
            fcf.append(this._info[key], a_data[key]);
          } else {
            this._info[key] = a_data[key];
          }
        }
      };

      this._findPackagePath = function (a_paths, a_fileName) {
        function clFind(a_path, a_fileName) {
          var statDir = modFs.lstatSync(a_path);
          if (statDir && !statDir.isDirectory()) return;
          var files = modFs.readdirSync(a_path);

          for (var i = 0; i < files.length; ++i) {
            var filePath = modPath.join(a_path, files[i]);
            var stat = modFs.lstatSync(filePath);
            if (!stat.isDirectory() && a_fileName == files[i]) return filePath;
          }

          ;

          for (var i = 0; i < files.length; ++i) {
            var filePath = modPath.join(a_path, files[i]);
            var stat = modFs.lstatSync(filePath);

            if (stat.isDirectory()) {
              var res = clFind(filePath, a_fileName);
              if (res) return res;
            }
          }

          ;
        }

        ;

        for (var i = a_paths.length - 1; i >= 0; --i) {
          var res = clFind(fcf.getPath(a_paths[i]), a_fileName);
          if (res) return res;
        }
      };
    };

    return NDetails.Package;
  }
});
fcf.module({
  name: "fcf:NTheme/Theme.js",
  dependencies: ["fcf:NServer/NDetails/Package.js"],
  module: function module(Package) {
    var NRender = fcf.prepareObject(fcf, "NRender");
    /*
    * @class  fcf::NRender::Theme
    * @brief <b>[client only]</b> Объект темы
    **/

    NRender.Theme = function (a_initializeOptions) {
      /*
      * @constructor
      * @param a_settings
      *         - obejct actions
      *         - string package
      *         - array  sources
      *         - array  extension
      *         - object configuration
      *         - object info [client only]
      **/
      var initializeOptions = fcf.append({}, a_initializeOptions, {
        extension: "theme",
        setConfiguration: false
      });
      var self = this;
      Package.call(this, initializeOptions);
      this.isTheme = true;
      this._aliases = {};
      this._views = {
        parts: {},
        all: {},
        cur: {}
      };
      fcf.prepareObject(this.getInfo(), "html.include");

      this.clientInitialize = function () {};

      var parentInitialize = this.initialize;

      this.initialize = function () {
        if (!fcf.isServer()) return this._clientInitialize();else return this._serverInitialize();
      };

      this.getDecor = function () {
        return this._info.decor;
      };

      this._clientInitialize = function () {
        this.setAliases(initializeOptions.configuration.getConfiguration().aliases);
        if (initializeOptions.info.aliases) this.setAliases(initializeOptions.info.aliases);
        this.setViews(initializeOptions.configuration.getConfiguration().views);
        if (initializeOptions.info.views) this.setViews(initializeOptions.info.views);
      };

      this._serverInitialize = function () {
        return parentInitialize.call(this).exec(function (a_act) {
          var extendsNames = Array.isArray(self._info["extends"]) ? self._info["extends"] : self._info["extends"] ? [self._info["extends"]] : [];
          var exts = [];
          new fcf.Actions({
            onError: function onError(a_error) {
              a_act.error(a_error);
            }
          }).each(extendsNames, function (a_subact, a_key, a_item) {
            if (fcf.application.getThemes().getThemes[a_item]) {
              exts.push(fcf.application.getThemes().getThemes[a_item]);
              a_subact.complete();
            } else {
              var subTheme = new NRender.Theme({
                actions: a_initializeOptions.actions,
                package: a_item,
                sources: a_initializeOptions.sources,
                extension: a_initializeOptions.extension,
                configuration: fcf.application.getConfiguration()
              });
              subTheme.initialize().then(function () {
                exts.push(subTheme);
                a_subact.complete();
              })["catch"](function (a_error) {
                a_subact.error(a_error);
              });
            }
          }).execAC(function () {
            self._applyExtends(exts);

            var packs = fcf.application.getPackages();

            for (var pm in packs) {
              if (typeof packs[pm].aliases == "object") {
                self.setAliases(packs[pm].aliases);
              }
            }

            if (typeof self._info.aliases === "object") {
              self.setAliases(self._info.aliases);
            }

            if (typeof self._info.views === "object") {
              self.setViews(self._info.views);
            }

            self._appendIncludes();

            a_act.complete();
          });
        });
      };

      this._applyExtends = function (a_extends) {
        var info = this.getInfo();
        if (!info.html) info.html = {};
        if (!info.html.include) info.html.include = {};
        var originalInclude = {};
        var originalDecor = {};
        fcf.each(a_extends, function (a_key, a_extend) {
          var einfo = a_extend.getInfo();

          if (einfo.html && einfo.html.include) {
            fcf.append(originalInclude, einfo.html.include);
          }

          if (einfo.decor) {
            fcf.append(originalDecor, einfo.decor);
          }
        });
        fcf.append(originalInclude, info.html.include);
        fcf.append(originalDecor, info.decor);
        info.html.include = originalInclude;
        info.decor = originalDecor;
      };

      this.setViews = function (a_objectViews) {
        for (var part in a_objectViews) {
          for (var view in a_objectViews[part]) {
            this.setView(part, view, a_objectViews[part][view]);
          }
        }
      };

      this.setView = function (a_part, a_view, a_template) {
        var partArr = a_part.split(".");
        var currentParts = this._views;

        for (var i = 0; i < partArr.length; ++i) {
          if (partArr[i] != "*") {
            if (!(partArr[i] in currentParts.parts)) currentParts.parts[partArr[i]] = {
              parts: {},
              cur: {},
              all: {}
            };
            currentParts = currentParts.parts[partArr[i]];
          } else {
            currentParts.all[a_view] = a_template;
            return;
          }
        }

        currentParts.cur[a_view] = a_template;
      };

      this.getView = function (a_part, a_type) {
        if (typeof a_type === "object") {
          var view = fcf.buildModeObject(a_part, a_type, "usage");

          if (view.template) {
            return {
              template: view.template,
              found: true
            };
          }

          a_type = a_type.type;
        }

        var partArr = a_part.split(".");
        var currentParts = this._views;
        var result = undefined;

        for (var i = 0; i < partArr.length; ++i) {
          if (a_type in currentParts.all) {
            result = {
              template: currentParts.all[a_type],
              found: true
            };
          }

          if (partArr[i] in currentParts.parts) {
            currentParts = currentParts.parts[partArr[i]];
          } else {
            currentParts = undefined;
            break;
          }
        }

        if (currentParts && a_type in currentParts.cur) {
          result = {
            template: currentParts.cur[a_type],
            found: true
          };
        } else if (currentParts && a_type in currentParts.all) {
          result = {
            template: currentParts.all[a_type],
            found: true
          };
        }

        if (!result) {
          var inheritanceMode = fcf.application.getInheritanceModes()[a_part];
          if (inheritanceMode) return this.getView(inheritanceMode, a_type);
        } else {
          return result;
        }

        return {
          template: "@controls:text",
          found: false
        };
      };

      this.setAliases = function (a_objectAliases) {
        for (var alias in a_objectAliases) {
          this.setAlias(alias, a_objectAliases[alias]);
        }
      };

      this.setAlias = function (a_alias, a_uri) {
        var alias = a_alias.split("&");
        alias = alias.length > 1 ? alias[1] : alias[0];
        this._aliases[alias] = a_uri;
      };

      this.getAliases = function () {
        return this._aliases;
      };

      this.resolveAlias = function (a_path) {
        if (a_path.charAt(0) != "@") return a_path;
        var subpart = a_path.split("+")[1];
        a_path = a_path.split("+")[0];
        var alias = a_path.substr(1);
        var result = alias in this._aliases ? this._aliases[alias] : a_path;
        if (subpart) result += "+" + subpart;
        return result;
      };

      this._appendIncludes = function () {
        var packs = fcf.application.getPackages();

        for (var packName in packs) {
          if (packs[packName].isTheme) continue;
          var inf = packs[packName].getInfo();
          if (inf.html && inf.html.include) fcf.append(this.getInfo().html.include, inf.html.include);
        }
      };
    };

    return NRender.Theme;
  }
});
if (fcf.isServer()) var fs = require('fs');
fcf.addException("ERROR_PACKAGE_NOT_FOUND", "Theme ${{theme}}$ not found");
fcf.module({
  name: "fcf:NTheme/Themes.js",
  dependencies: ["fcf:NTheme/Theme.js"],
  module: function module(Theme) {
    var NRender = fcf.prepareObject(fcf, "NRender");

    NRender.Themes = function (a_initializeOptions) {
      /**
      * @fn void constructor(a_initializeOptions)
      * @param object a_initializeOptions
      *         - array             sources
      *         - string            defaultTheme
      *         - object            configuration
      **/
      var self = this;
      this._themes = {};
      this._aliases = {};
      this._views = {};
      this._defaultTheme = a_initializeOptions.defaultTheme ? a_initializeOptions.defaultTheme : "defaultTheme";

      this.getTheme = function (a_name, a_safeMode) {
        var result = fcf.empty(a_name) ? this._themes[this._defaultTheme] : this._themes[a_name] ? this._themes[a_name] : a_safeMode ? this._themes[this._defaultTheme] : undefined;
        var name = a_name ? a_name : this._defaultTheme;
        if (!result && !a_safeMode) throw new fcf.Exception("ERROR_PACKAGE_NOT_FOUND", {
          theme: name
        });
        return result;
      };

      this.getThemes = function () {
        return this._themes;
      };

      this.getDefaultThemeName = function () {
        return this._defaultTheme;
      };

      this.setDefaultThemeName = function (a_defaultThemeName) {
        this._defaultTheme = a_defaultThemeName;
      };

      this.attachTheme = function (a_name, a_theme) {
        this._themes[a_name] = a_theme;
      };

      this.initialize = function () {
        var themes = undefined;
        var actions = fcf.actions();
        return actions.exec(function (a_act) {
          self._findThemes(function (a_error, a_themes) {
            if (a_error) {
              a_act.error(a_error);
              return;
            }

            themes = a_themes;
            a_act.complete();
          });
        }).each(function () {
          return themes;
        }, function (a_act, a_key, a_themeName) {
          var theme = new Theme({
            package: a_themeName,
            sources: a_initializeOptions.sources,
            configuration: a_initializeOptions.configuration
          });
          self._themes[a_themeName] = theme;
          fcf.actions(theme.initialize()).then(function () {
            a_act.complete();
          })["catch"](function (a_error) {
            a_act.error(a_error);
          });
        }).then(function () {
          for (var key in self._themes) {
            self._themes[key].setAliases(self._aliases);

            self._themes[key].setViews(self._views);
          }
        });
      };

      this.setAliases = function (a_aliases) {
        for (var key in this._themes) {
          this._themes[key].setAliases(a_aliases);
        }

        fcf.append(this._aliases, a_aliases);
      };

      this.setViews = function (a_views) {
        for (var key in this._themes) {
          this._themes[key].setViews(a_views);
        }

        for (var key in a_views) {
          if (!this._views[key]) this._views[key] = {};
          fcf.append(this._views[key], a_views[key]);
        }
      };

      this._findThemes = function (a_cb) {
        var themes = [];
        var actions = new fcf.Actions({
          onComplete: function onComplete() {
            a_cb(undefined, themes);
          },
          onError: function onError(a_error) {
            a_cb(a_error);
          }
        });

        function clReadDir(a_path) {
          a_path = fcf.getPath(a_path);
          actions.append(function (a_extAct) {
            fs.readdir(a_path, function (a_error, a_items) {
              if (a_error) throw new fcf.Exception("ERROR_TEST_OPEN_DIRECTORY", {
                directory: a_path
              });
              actions.each(a_items, function (a_act, a_key, a_item) {
                var pathFile = a_path + "/" + a_item;

                if (fs.lstatSync(pathFile).isFile()) {
                  var fileExtension = fcf.getExtension(pathFile);

                  if (fileExtension != "theme") {
                    a_act.complete();
                    return;
                  }

                  themes.push(fcf.getShortFileName(pathFile));
                  a_act.complete();
                } else {
                  clReadDir(pathFile);
                  a_act.complete();
                }
              });
              a_extAct.complete();
            });
          });
        }

        ;

        if (Array.isArray(a_initializeOptions.sources)) {
          for (var i = 0; i < a_initializeOptions.sources.length; ++i) {
            clReadDir(a_initializeOptions.sources[i]);
          }
        }

        actions.startup();
      };
    };

    return NRender.Themes;
  }
});
fcf.module({
  name: "fcf:NRender/NDetails/ArgsDependecies.js",
  dependencies: [],
  module: function module() {
    var NDetails = fcf.prepareObject(fcf, "NRender.NDetails");
    var innerStorage = {};
    /*
    * @class fcf::NRender::NDetails::ArgOrderDetector
    * @brief Класс анализатора порядка элементов
    **/

    NDetails.ArgsDependecies = function (a_options) {
      var self = this;

      this.buildOrder = function (a_args) {
        var dependencies = {};

        for (var key in a_args) {
          dependencies[key] = [];
          if (typeof a_args[key] !== "object") continue;

          if (a_args[key].tokenize) {
            var deps = this._getTokenizeDependencies(a_args[key]);

            fcf.append(dependencies[key], deps);
          }

          if (Array.isArray(a_args[key].dependencies)) {
            fcf.append(dependencies[key], a_args[key].dependencies);
          }
        }

        dependencies = this._normalizeOrderDeps(dependencies);
        return dependencies;
      };

      this._normalizeOrderDeps = function (a_orderDeps) {
        var orderDeps = {};

        for (var key in a_orderDeps) {
          var nkey = fcf.normalizeObjectAddress(key);
          orderDeps[nkey] = [];

          for (var itemKey in a_orderDeps[key]) {
            orderDeps[nkey].push(fcf.normalizeObjectAddress(a_orderDeps[key][itemKey]));
          }
        }

        return orderDeps;
      };

      this._getTokenizeDependencies = function (a_arg, a_dst) {
        var isRoot = false;

        if (a_dst === undefined) {
          a_dst = {};
          isRoot = true;
        }

        for (var k in a_arg) {
          if (typeof a_arg[k] === "string") {
            var keys = fcf.getVariablesString(a_arg[k]);

            for (var i = 0; i < keys.length; ++i) {
              a_dst[keys[i]] = true;
            }
          } else if (typeof a_arg[k] === "object") {
            this._getTokenizeDependencies(a_arg[k], a_dst);
          }
        }

        if (isRoot) {
          var result = [];

          for (var k in a_dst) {
            result.push(k);
          }

          return result;
        }
      };
    };

    return NDetails.ArgsDependecies;
  }
});

if (fcf.isServer()) {
  var libFS = require('fs');
}

fcf.module({
  name: "fcf:NRender/NDetails/Loader.js",
  dependencies: ["fcf:NRender/NDetails/ArgsDependecies.js"],
  module: function module(ArgsDependecies) {
    var NDetails = fcf.prepareObject(fcf, "NRender.NDetails");
    fcf.addException("ERROR_RENDER_SERVER_ONLY_TEMPLATE", "The '${{template}}$' template can only be rendered on the server");
    fcf.addException("ERROR_RENDER_TEMPLATE_NOT_FOUND", "Element '${{template}}$' template not found");
    var innerFileStorage = {};
    var innerWatchFiles = {};

    NDetails.Loader = function (a_options) {
      var self = this;
      this._options = fcf.append({}, a_options);
      this._argOrderDetector = new ArgsDependecies({});

      this.setSettings = function (a_options) {
        fcf.append(this._options, a_options);
      };

      this.load = function (a_path, a_state, a_cb) {
        if (typeof a_state === "function") {
          a_cb = a_state;
          a_state = {
            theme: fcf.application.getThemes().getTheme("defaultTheme", true)
          };
        }

        a_path = a_path.split("+")[0];
        a_path = a_state.theme.resolveAlias(a_path);
        var arrPath = a_path.split("+");
        var path = arrPath[0];
        var blocks = [arrPath[1]];

        this._loadTemplate(a_path, a_state, a_path).then(function (a_template) {
          a_cb(undefined, a_template);
        })["catch"](function (a_error) {
          a_cb(a_error);
        });
      };

      this._loadTemplate = function (a_path, a_state, a_mainTemplate) {
        a_path = fcf.getPath(a_path);
        var template = undefined;
        return fcf.actions().then(function () {
          if (innerFileStorage[a_path]) {
            return innerFileStorage[a_path];
          } else {
            return fcf.load({
              path: a_path,
              aliases: a_state.theme.getAliases()
            }).then(function (a_data) {
              innerFileStorage[a_path] = a_data;

              if (fcf.isServer() && !innerWatchFiles[a_path]) {
                innerWatchFiles[a_path] = true;
                libFS.watchFile(a_path, {
                  interval: 1000
                }, function (a_eventType, a_filename) {
                  delete innerFileStorage[a_path];
                });
              }

              return a_data;
            });
          }
        }).then(function (a_data) {
          var ov = fcf.NDetails.currentTemplate;
          fcf.NDetails.currentTemplate = a_mainTemplate;
          template = self._parseTemplate(a_data, a_path);
          fcf.NDetails.currentTemplate = ov;
        }) //Loading template hooks
        .then(function () {
          if (!fcf.isServer() && template.options.serverOnly) {
            return template;
          } else {
            return fcf.actions().each(template.templates, function (a_act, a_key, a_subTemplate) {
              var hookFileArr = a_path.split(".");
              hookFileArr.pop();
              if (a_key != "") hookFileArr[hookFileArr.length - 1] += "+" + a_key;
              hookFileArr.push("hooks");
              hookFileArr.push("js");
              var hookFilePath = hookFileArr.join(".");
              fcf.requireEx([hookFilePath], {
                showError: false
              }, function (error, hooks) {
                if (error && error.toString().indexOf("SyntaxError") !== -1) {
                  a_act.error(error);
                  return;
                }

                if (hooks) {
                  var nh = {};
                  fcf.each(hooks.hooksProgramableArgument, function (a_key, a_hook) {
                    nh[fcf.normalizeObjectAddress(a_key)] = a_hook;
                  });
                  hooks.hooksProgramableArgument = nh;
                  var nh = {};
                  fcf.each(hooks.hooksBeforeArgument, function (a_key, a_hook) {
                    nh[fcf.normalizeObjectAddress(a_key)] = a_hook;
                  });
                  hooks.hooksBeforeArgument = nh;
                  var nh = {};
                  fcf.each(hooks.hooksAfterArgument, function (a_key, a_hook) {
                    nh[fcf.normalizeObjectAddress(a_key)] = a_hook;
                  });
                  hooks.hooksAfterArgument = nh;
                  fcf.append(a_subTemplate.hooks, hooks);
                }

                a_act.complete();
              });
            });
          }
        }) //Apply the inherited functionalit
        .then(function () {
          if (!fcf.isServer() && template.options.serverOnly) {
            return template;
          } else {
            if (!template.options["extends"]) {
              return template;
            } else {
              return self._loadTemplate(template.options["extends"], a_state, a_mainTemplate).then(function (a_etemplate) {
                return self._inheritance(a_etemplate, template);
              });
            }
          }
        });
      };

      this._inheritance = function (a_baseTemplate, a_template) {
        var result = {
          options: {},
          templates: {}
        };
        fcf.append(true, result.options, a_baseTemplate.options);
        fcf.append(true, result.options, a_template.options);
        var names = {};
        fcf.each(a_template.templates, function (k) {
          names[k] = true;
        });
        fcf.each(a_baseTemplate.templates, function (k) {
          names[k] = true;
        });

        for (var tname in names) {
          if (!result.templates[tname]) result.templates[tname] = {
            arguments: {},
            template: {
              items: [],
              template: ""
            },
            hooks: {}
          }; // build arguments

          var args = a_baseTemplate.templates[tname] && a_baseTemplate.templates[tname].arguments ? a_baseTemplate.templates[tname].arguments : {};
          result.templates[tname].arguments = self._normalzieArgs(args);
          var args = a_template.templates[tname] && a_template.templates[tname].arguments ? a_template.templates[tname].arguments : {};
          fcf.append(result.templates[tname].arguments, self._normalzieArgs(args)); // build templates

          if (a_baseTemplate.templates[tname] && !fcf.empty(a_baseTemplate.templates[tname].template)) result.templates[tname].template = a_baseTemplate.templates[tname].template;
          if (a_template.templates[tname] && !fcf.empty(a_template.templates[tname].template)) result.templates[tname].template = a_template.templates[tname].template; // build hooks

          if (a_baseTemplate.templates[tname] && !fcf.empty(a_baseTemplate.templates[tname].hooks)) {
            fcf.append(result.templates[tname].hooks, a_baseTemplate.templates[tname].hooks);
            if (!result.templates[tname].hooks.prototype) result.templates[tname].hooks.prototype = {};
            result.templates[tname].hooks.prototype = a_baseTemplate.templates[tname].hooks;
          }

          if (a_template.templates[tname] && !fcf.empty(a_template.templates[tname].hooks)) {
            fcf.append(result.templates[tname].hooks, a_template.templates[tname].hooks);
            var dstHooks = result.templates[tname].hooks;
            var srcHooks = dstHooks.prototype;

            if (srcHooks) {
              if (!fcf.empty(srcHooks.hooksProgramableArgument)) {
                for (var key in srcHooks.hooksProgramableArgument) {
                  if (!(key in dstHooks.hooksProgramableArgument)) dstHooks.hooksProgramableArgument[key] = srcHooks.hooksProgramableArgument[key];
                }
              }

              if (!fcf.empty(srcHooks.hooksBeforeArgument)) {
                for (var key in srcHooks.hooksBeforeArgument) {
                  if (!(key in dstHooks.hooksBeforeArgument)) dstHooks.hooksBeforeArgument[key] = srcHooks.hooksBeforeArgument[key];
                }
              }

              if (!fcf.empty(srcHooks.hooksAfterArgument)) {
                for (var key in srcHooks.hooksAfterArgument) {
                  if (!(key in dstHooks.hooksAfterArgument)) dstHooks.hooksAfterArgument[key] = srcHooks.hooksAfterArgument[key];
                }
              }
            }
          }
        }

        return result;
      };

      this._normalzieArgs = function (a_args) {
        var result = {};

        for (var key in a_args) {
          result[fcf.normalizeObjectAddress(key)] = fcf.append(true, a_args[key]);
        }

        return result;
      };

      this._parseTemplate = function (a_ctxt, a_path) {
        var result = {
          options: {},
          templates: {}
        };
        var blocksPositions = [];
        var lstpos = 0;

        do {
          var blockPositions = this._getBlockPositions(a_ctxt, lstpos);

          lstpos = blockPositions.dataEnd;

          if (lstpos) {
            blocksPositions.push(blockPositions);
          }
        } while (lstpos);

        for (var i = 0; i < blocksPositions.length; ++i) {
          this._parseBlock(result, a_ctxt, blocksPositions[i], a_path);
        }

        return result;
      };

      this._parseBlock = function (a_dst, a_ctxt, a_blockPositions, a_path) {
        var headerLine = a_ctxt.substr(a_blockPositions.headerBeg + 3, a_blockPositions.headerEnd - a_blockPositions.headerBeg - 3);
        var arrHeaderLine = fcf.splitSpace(headerLine);
        var type = arrHeaderLine[0] ? arrHeaderLine[0].toUpperCase() : "";
        var name = arrHeaderLine[1] ? arrHeaderLine[1] : "";

        if (!a_dst.templates[name]) {
          a_dst.templates[name] = {
            arguments: {},
            template: {},
            hooks: {}
          };
        }

        if (type == "OPTIONS") {
          var data = a_ctxt.substr(a_blockPositions.dataBeg, a_blockPositions.dataEnd - a_blockPositions.dataBeg);

          var stringNumber = this._getStringNumber(a_ctxt, a_blockPositions.dataBeg);

          var options = fcf.scriptExecutor.parse(data, {}, a_path, stringNumber);
          fcf.append(a_dst.options, options);
        }

        if (type == "ARGUMENTS") {
          var _data = a_ctxt.substr(a_blockPositions.dataBeg, a_blockPositions.dataEnd - a_blockPositions.dataBeg);

          var _stringNumber = this._getStringNumber(a_ctxt, a_blockPositions.dataBeg);

          var args = fcf.scriptExecutor.parse(_data, {}, a_path, _stringNumber);
          var normalizeArgs = {};

          for (var _k in args) {
            normalizeArgs[fcf.normalizeObjectAddress(_k)] = args[_k];
          }

          fcf.append(a_dst.templates[name].arguments, normalizeArgs);
        } else if (type == "TEMPLATE") {
          var content = a_ctxt.substr(a_blockPositions.dataBeg, a_blockPositions.dataEnd - a_blockPositions.dataBeg);
          a_dst.templates[name].template = this._contentToJS(this._removeLastLF(content));
          a_dst.templates[name].template.stringNumber = this._getStringNumber(a_ctxt, a_blockPositions.dataBeg);
        }
      };

      this._getStringNumber = function (a_txt, a_position) {
        if (a_position === undefined) a_position = a_txt.length;
        var pos = undefined;
        var n = 0;

        while (true) {
          pos = a_txt.indexOf("\n", pos !== undefined ? pos + 1 : 0);
          if (pos == -1 || pos > a_position) return n;
          ++n;
        }
      };

      this._getBlockPositions = function (a_ctxt, a_start) {
        var result = {
          headerBeg: undefined,
          headerEnd: undefined,
          dataBeg: undefined,
          dataEnd: undefined
        };
        var pos;

        while (true) {
          pos = a_ctxt.indexOf("//~", a_start);

          if (pos != -1 && pos != 0 && a_ctxt[pos - 1] != "\n") {
            a_start = pos;
            continue;
          }

          if (pos == -1) return result;
          var dpos = pos + 3;
          if (dpos >= a_ctxt.length) return result;
          var epos = dpos;

          while (a_ctxt.charCodeAt(epos) > 32 && epos < a_ctxt.length) {
            ++epos;
          }

          if (epos >= a_ctxt.length) return result;
          var type = a_ctxt.substring(dpos, epos).toLowerCase();
          var validBlocks = {
            "template": true,
            "options": true,
            "arguments": true
          };

          if (!(type in validBlocks)) {
            a_start = epos;
            continue;
          }

          break;
        }

        result.headerBeg = pos;

        if (result.headerBeg == -1) {
          result.headerBeg = undefined;
          return result;
        }

        result.headerEnd = a_ctxt.indexOf("\n", pos);

        if (result.headerEnd == -1) {
          result.headerBeg = undefined;
          result.headerEnd = undefined;
          return result;
        }

        result.dataBeg = result.headerEnd + 1 > a_ctxt.length ? undefined : result.headerEnd + 1;

        if (result.dataBeg === undefined) {
          result.headerBeg = undefined;
          result.headerEnd = undefined;
          return result;
        }

        var lstpos = result.dataBeg;

        while (true) {
          pos = a_ctxt.indexOf("//~", lstpos);

          if (pos != -1 && a_ctxt[pos - 1] != "\n") {
            lstpos = pos;
            continue;
          }

          break;
        }

        result.dataEnd = pos != -1 ? pos : a_ctxt.length;
        return result;
      };

      this._removeLastLF = function (a_content) {
        if (a_content.length >= 2 && a_content.charAt(a_content.length - 2) == "\r" && a_content.charAt(a_content.length - 1) == "\n") return a_content.substr(0, a_content.length - 2);
        if (a_content.length >= 1 && a_content.charAt(a_content.length - 1) == "\n") return a_content.substr(0, a_content.length - 1);
        return a_content;
      };

      this._contentToJS = function (a_content) {
        var items = [];
        var pos = 0;
        var startPos = 0;
        var type = "content";

        while (pos != -1) {
          var pos = a_content.indexOf("{{", pos);

          if (pos !== -1 && pos !== 0 && a_content[pos - 1] == "$") {
            if (pos - startPos - 1) items.push({
              type: "content",
              data: a_content.substr(startPos, pos - startPos - 1)
            });
            var endPos = a_content.indexOf("}}$", pos);

            if (endPos != -1) {
              items.push({
                type: "variable",
                data: fcf.trim(a_content.substr(pos + 2, endPos - pos - 2))
              });
              pos = endPos + 3;
              startPos = pos;
            } else {
              pos = -1;
            }
          } else if (pos !== -1 && pos !== 0 && a_content[pos - 1] == "#") {
            if (pos - startPos - 1) items.push({
              type: "content",
              data: a_content.substr(startPos, pos - startPos - 1)
            });
            var endPos = a_content.indexOf("}}#", pos);

            if (endPos != -1) {
              items.push({
                type: "variable",
                data: fcf.trim(a_content.substr(pos + 2, endPos - pos - 2))
              });
              pos = endPos + 3;
              startPos = pos;
            } else {
              pos = -1;
            }
          } else if (pos !== -1 && pos !== 0 && a_content[pos - 1] == "@") {
            if (pos - startPos - 1) items.push({
              type: "content",
              data: a_content.substr(startPos, pos - startPos - 1)
            });
            var _endPos = undefined;
            var fpos = pos;
            var counter = 0;

            while (true) {
              var startNextBlock = a_content.indexOf("@{{", fpos);
              _endPos = a_content.indexOf("}}@", fpos);
              if (!counter && (startNextBlock > _endPos || startNextBlock == -1 || _endPos == -1)) break;

              if (startNextBlock > _endPos) {
                fpos = _endPos + 3;
                ++counter;
              } else {
                fpos = startNextBlock + 3;
                --counter;
              }
            }

            if (_endPos != -1) {
              items.push({
                type: "calculation",
                data: fcf.trim(fcf.trim(a_content.substr(pos + 2, _endPos - pos - 2)), [";"])
              });
              pos = _endPos + 3;
              startPos = pos;
            } else {
              pos = -1;
            }
          } else if (pos !== -1 && pos !== 0 && a_content[pos - 1] == "!") {
            if (pos - startPos - 1) items.push({
              type: "content",
              data: a_content.substr(startPos, pos - startPos - 1)
            });
            var endPos = a_content.indexOf("}}!", pos);

            if (endPos != -1) {
              items.push({
                type: "translate",
                data: fcf.trim(a_content.substr(pos + 2, endPos - pos - 2))
              });
              pos = endPos + 3;
              startPos = pos;
            } else {
              pos = -1;
            }
          } else if (pos !== -1 && pos !== 0 && a_content[pos - 1] == "%") {
            if (pos - startPos - 1) items.push({
              type: "content",
              data: a_content.substr(startPos, pos - startPos - 1)
            });
            var endPos = a_content.indexOf("}}%", pos);

            if (endPos != -1) {
              items.push({
                type: "code",
                data: a_content.substr(pos + 2, endPos - pos - 2)
              });
              pos = endPos + 3;
              startPos = pos;
            } else {
              pos = -1;
            }
          } else if (pos == -1) {
            if (a_content.length - startPos) items.push({
              type: "content",
              data: a_content.substr(startPos, a_content.length - startPos)
            });
            pos = -1;
          } else {
            pos = pos + 2;
          }
        }

        var result = "var _2318115_block_env={args: args, route: route, projections: projections, decor: decor};";

        for (var i = 0; i < items.length; ++i) {
          if (items[i].type == "code") {
            result += items[i].data;
            result += ";";
          } else if (items[i].type == "variable") {
            result += "render.write(fcf.resolve(_2318115_block_env, '" + items[i].data + "' ) );";
          } else if (items[i].type == "calculation") {
            result += "render.write(" + items[i].data + ");";
          } else if (items[i].type == "translate") {
            result += "render.write(fcf.t(\"" + fcf.escapeQuotes(items[i].data, undefined, true) + "\", undefined, true));";
          } else if (items[i].type == "content") {
            result += "render.write(_innerfcf_currentTemplateBlocks[" + i + "].data);";

            var lines = this._getStringNumber(items[i].data);

            for (var _i2 = 0; _i2 < lines; ++_i2) {
              result += "\n";
            }
          }
        }

        return {
          items: items,
          template: result
        };
      };
    };

    return NDetails.Loader;
  }
});
fcf.module({
  name: "fcf:NRender/NDetails/TemplateRender.js",
  dependencies: [],
  module: function module() {
    var NDetails = fcf.prepareObject(fcf, "NRender.NDetails");
    var debugIncludeFiles = ["fcf:NRender/NDetails/Helper.js", "fcf:NRender/TaskInfo.js", "fcf:NFSQL/NFilter/Filter.js", "fcf:NServer/PackageHandler.js", "fcf:NServer/NDetails/Package.js", "fcf:NTheme/Theme.js", "fcf:NTheme/Themes.js", "fcf:NRender/NDetails/ArgsDependecies.js", "fcf:NRender/NDetails/Loader.js", "fcf:NRender/NDetails/TemplateRender.js", "fcf:NRender/NDetails/TemplateProcessor.js", "fcf:NRender/Template.js", "fcf:NRender/NDetails/ArgsBuilder.js", "fcf:NRender/Render.js", "fcf:NFSQL/Projections.js", "fcf:NFSQL/NDetails/Errors.js", "fcf:NFSQL/NDetails/SingleBuilder.js", "fcf:NFSQL/Builder.js", "fcf:NFSQL/NDetails/ClientStorage.js", "fcf:NFSQL/Storage.js", "fcf:NEvent/Error.js", "fcf:NServer/Configuration.js", "fcf:NClient/LocalData.js", "fcf:NClient/Router.js", "fcf:NClient/Application.js", "fcf:NRender/Wrapper.js"];
    var innerStorage = {};
    /*
    * @class fcf::NRender::NDetails::ArgOrderDetector
    * @brief Класс анализатора порядка элементов
    **/

    NDetails.TemplateRender = function (a_initializeOptions) {
      var self = this;
      this.buffer = "";
      this.templates = {};
      this.markerPrefix = "<marker c9193820-251d-11ea-bc52-d7f06800af03 ";
      this.markerSuffix = "></marker>";
      this.markerHeader = this.markerPrefix + "header" + this.markerSuffix;
      ;
      this._callMap = {};

      this.write = function (a_content) {
        this.buffer += fcf.str(a_content);
      };

      this.template = function (a_options, a_args) {
        if (typeof a_options === "string") {
          a_options = {
            template: a_options,
            args: a_args
          };
        }

        var fcfCP = this._getCallPosition();

        var templateMarker = this.markerPrefix + fcf.uuid() + this.markerSuffix;
        if (!a_options.args) a_options.args = {};
        var newArgs = {};

        for (var k in a_options.args) {
          newArgs[fcf.normalizeObjectAddress(k)] = a_options.args[k];
        }

        a_options.args = newArgs;
        a_options.args = fcf.append({}, a_options.args, {
          fcfCP: fcfCP,
          fcfParent: a_initializeOptions.args.fcfWrapper ? a_initializeOptions.args.fcfId : undefined
        });
        this.templates[templateMarker] = fcf.append(true, {}, {
          type: "template",
          options: a_options
        });
        return templateMarker;
      };

      this.view = function (a_options) {
        var fcfCP = this._getCallPosition();

        var templateMarker = this.markerPrefix + fcf.uuid() + this.markerSuffix;
        if (!a_options.args) a_options.args = {};
        a_options.args = fcf.append({}, a_options.args, {
          fcfCP: fcfCP,
          fcfParent: a_initializeOptions.args.fcfWrapper ? a_initializeOptions.args.fcfId : undefined
        });
        this.templates[templateMarker] = fcf.append(true, {}, {
          type: "view",
          options: a_options
        });
        return templateMarker;
      };

      this.header = function () {
        this.templates[this.markerHeader] = {
          type: "header",
          options: {}
        };
        return this.markerHeader;
      };

      this._getCallPosition = function () {
        var stackArr = new Error().stack.split("\n");
        var strInfo = fcf.trim(stackArr[0].indexOf(":") == -1 ? stackArr[3] : stackArr[2], [" ", ")"]);
        var callPostition = "";
        var dc = 0;

        if (strInfo.length) {
          var charCode0 = "0".charCodeAt(0);
          var charCode9 = "9".charCodeAt(0);

          for (var i = strInfo.length - 1; i >= 0; --i) {
            var charCode = strInfo.charCodeAt(i);
            if (charCode >= charCode0 && charCode <= charCode9) continue;
            ++dc;

            if (dc >= 2) {
              callPostition = strInfo.substr(i + 1);
              break;
            }
          }
        }

        var cp = "block:" + callPostition;
        if (!(cp in this._callMap)) this._callMap[cp] = 0;
        cp += "-" + ++this._callMap[cp];
        return cp;
      };

      this._header = function () {
        var theme = fcf.application.getThemes().getTheme(a_initializeOptions.args.fcfTheme);
        if (!theme) theme = fcf.application.getThemes().getTheme();
        var result = "";
        var themeInfo = theme.getInfo();
        result += '    <style> .fcfwrapper { display: inline; }</style>\n';
        result += '    <script src="' + fcf.getPath("fcf:fcf.js", false) + '"></script>\n';
        result += '    <script src="' + fcf.getPath("@url:fcfProjections", false) + '"></script>\n';

        if (!fcf.getContext().get("debug")) {
          result += '    <script src="/fcfpackages/fcf/include.js"></script>\n';
        } else {
          for (var i = 0; i < debugIncludeFiles.length; ++i) {
            var filePath = fcf.getPath(debugIncludeFiles[i], false);
            result += '    <script src="' + filePath + '"></script>\n';
          }
        }

        result += "    <script>\n";
        var routeData = a_initializeOptions.request.getRouteData();
        var route = routeData.route && routeData.route.data && routeData.route.data.route ? routeData.route.data.route : routeData.path;
        var defaultTheme = a_initializeOptions.state.defaultTheme ? a_initializeOptions.state.defaultTheme.getName() : undefined;
        if (!defaultTheme) defaultTheme = fcf.application.getThemes().getDefaultThemeName();
        var context = fcf.getContext();
        var sendContext = {};

        for (var k in context) {
          if (k != "safeEnv") sendContext[k] = context[k];
        }

        var options = {
          context: sendContext,
          route: route,
          clientRenderingMode: fcf.application.getSettings().clientRenderingMode == "server" ? "server" : "client",
          defaultTheme: defaultTheme,
          fileСaching: fcf.application.getSettings().fileСaching,
          renderStorage: a_initializeOptions.state.renderStorage
        };
        result += "      fcf.application.setSettings(" + JSON.stringify(options) + ");";
        var inlineRenderRestore = "{renderRestore:{";
        fcf.each(a_initializeOptions.state.sources, function (a_id, a_control) {
          inlineRenderRestore += "\"" + fcf.escapeQuotes(a_id) + "\":{";
          fcf.each(a_control, function (a_key, a_value) {
            inlineRenderRestore += "\"" + fcf.escapeQuotes(a_key) + "\": ";

            if (fcf.isArg(a_value)) {
              inlineRenderRestore += "fcf.arg(\"" + a_value.type + "\",";
              var value = fcf.arg({}, a_value);
              delete value.type;
              inlineRenderRestore += JSON.stringify(value);
              inlineRenderRestore += ")";
            } else {
              inlineRenderRestore += JSON.stringify(a_value);
            }

            inlineRenderRestore += ",";
          });
          inlineRenderRestore += "},";
        });
        inlineRenderRestore += "}}";
        result += "      fcf.application.setSettings(" + inlineRenderRestore + ");\n";
        result += "    </script>\n";
        result += '    <script src="/fcfpackages/fcf/packages.js"></script>\n';
        var includeFilesMap = {};
        var includeFiles = [];
        fcf.each(fcf.application.getConfiguration().getConfiguration().html.include, function (a_key, a_path) {
          var path = fcf.getPath(a_path, false);

          if (!includeFilesMap[path]) {
            includeFilesMap[path] = true;
            includeFiles.push(path);
          }
        });
        fcf.each(themeInfo.html.include, function (a_key, a_path) {
          var path = fcf.getPath(a_path, false);

          if (!includeFilesMap[path]) {
            includeFilesMap[path] = true;
            includeFiles.push(path);
          }
        });

        for (var path in a_initializeOptions.state.include) {
          path = fcf.getPath(path, false);

          if (!includeFilesMap[path]) {
            includeFilesMap[path] = true;
            includeFiles.push(path);
          }
        }

        fcf.each(includeFiles, function (a_key, a_path) {
          var ext = fcf.getExtension(a_path);

          if (ext == "css") {
            result += '    <link rel="stylesheet" type="text/css" href="' + a_path + '">\n';
          } else if (ext == "js") {
            result += '    <script src="' + a_path + '"></script>\n';
          }
        });
        return result;
      };
    };

    return NDetails.TemplateRender;
  }
});
fcf.module({
  name: "fcf:NRender/NDetails/TemplateProcessor.js",
  dependencies: ["fcf:NRender/NDetails/TemplateRender.js", "fcf:NRender/NDetails/Helper.js"],
  module: function module(TemplateRender, helper) {
    var NDetails = fcf.prepareObject(fcf, "NRender.NDetails");

    NDetails.TemplateProcessor = function (a_settings) {
      /**
      * @fn constructor(a_settings)
      * @param fcf::NRender::Render           render рендер шаблона
      * @param fcf::NRender::NDetails::Loader loader загрузчик информации о шаблоне
      * @param object                         args   объект аргументов шаблона
      **/
      var self = this;
      /**
      * @fn void build(a_options)
      * @param object a_options
      *         - string                          template      адрес шаблона
      *         - object                          rawTemplate   объект информации о шаблоне
      *         - object                          request       Объекта запроса от клиента
      *         - object                          route         объект информации о маршруте
      *         - object                          context       объект информации о маршруте
      *         - fcf::NRender::NDetails::Loader  loader        объект загрузчика данных о шаблоне
      *         - object                          args
      *         - object                          sources       объект с исходными данными аргументов шаблона
      *         - object                          aliases       Алиасы путей шаблонов
      *         - object                          state         состояние рекурсивного рендеринга
      *         - object                          projections   объект-карта проекций
      *         - bool                            update [optional] флаг обновления повторной отрисовки на клиенте
      *         - function  onResult                            Обратный вызов результата \n
      *                  Сигнатура: void onResult(fcf::Exception a_error, a_content)
      **/

      this.build = function (a_options) {
        var template = a_options.template.split("+")[0];
        var templateRender = new TemplateRender({
          request: a_options.request,
          args: a_options.args,
          state: a_options.state
        });

        var renderingBlocks = self._getRenderingBlocks(a_options.template, a_options.rawTemplate, a_options.aliases ? a_options.aliases : {});

        var projections = a_options.projections ? a_options.projections : fcf.application.getProjections().getProjections();
        var decor = typeof a_options.state.theme.getInfo().decor == "object" ? a_options.state.theme.getInfo().decor : {};
        var aliases = typeof a_options.state.theme.getInfo().aliases == "object" ? a_options.state.theme.getInfo().aliases : {};
        fcf.setContext(a_options.context);

        try {
          self._renderBlock({
            render: templateRender,
            args: a_options.args,
            sources: a_options.sources,
            projections: projections,
            route: a_options.route,
            decor: decor,
            aliases: aliases,
            template: function template(a_template, a_args) {
              return render.template({
                template: a_template,
                args: a_args
              });
            },
            stringNumber: a_options.rawTemplate.template.stringNumber,
            _innerfcf_currentTemplate: a_options.rawTemplate.template.template,
            _innerfcf_currentTemplateBlocks: a_options.rawTemplate.template.items
          }, template);
        } catch (e) {
          a_options.onResult(e);
          return;
        }

        var result = templateRender.buffer;

        if (a_options.args.fcfWrapper) {
          var content = "<div ";
          content += "fcftemplate=\"" + a_options.state.theme.resolveAlias(a_options.template) + "\" ";
          content += " id='" + a_options.args.fcfId + "' ";
          content += " class='fcfwrapper " + fcf.str(a_options.args.fcfClass) + "' ";
          content += a_options.args.fcfEvntid ? " fcfevntid='" + a_options.args.fcfEvntid + "'" : "";
          if (a_options.args.fcfStyle) content += " style='" + a_options.args.fcfStyle + "' ";

          if (typeof a_options.args.fcfAttributes == "object") {
            for (var k in a_options.args.fcfAttributes) {
              content += " " + k + "=\"" + a_options.args.fcfAttributes[k] + "\" ";
            }
          }

          if (a_options.args.fcfParent) content += "fcfparent=\"" + a_options.args.fcfParent + "\" ";
          if (a_options.args.fcfAlias) content += "fcfalias=\"" + a_options.args.fcfAlias + "\" ";
          content += ">" + result + "</div>";
          result = content;
        }

        var inlineTemplates = {};

        (function (inlineTemplates) {
          fcf.actions({
            onError: function onError(a_error) {
              a_options.onResult(a_error);
            }
          }).each(templateRender.templates, function (a_act, a_key, a_templateInfo) {
            var inheritArgs = {};
            helper.appendChildInfo(inheritArgs, a_templateInfo.options.args, a_options.args.fcfChildsArgs);

            if (a_key != templateRender.markerHeader) {
              if (a_templateInfo.type === "template") {
                var args = fcf.append({}, a_templateInfo.options.args, inheritArgs);
                var options = fcf.append({}, a_templateInfo.options, {
                  request: a_options.request,
                  route: a_options.route,
                  state: a_options.state,
                  update: a_options.update,
                  context: a_options.context,
                  args: args,
                  reqursion: true,
                  onResult: function onResult(a_error, a_template) {
                    if (a_error) {
                      fcf.log.err("Render", a_error);
                      a_act.error(a_error);
                      return;
                    }

                    inlineTemplates[a_key] = a_template.content;
                    a_act.complete();
                  }
                });

                if (options.template.charAt(0) == "+") {
                  options.template = a_options.template.split("+")[0] + options.template;
                }

                a_options.render.render(options);
              } else if (a_templateInfo.type === "view") {
                var options = {
                  args: {}
                };
                var mode = a_templateInfo.options.mode ? a_templateInfo.options.mode : a_templateInfo.options.view && a_templateInfo.options.view.mode ? a_templateInfo.options.view.mode : "read";
                var view = fcf.buildModeObject(mode, a_templateInfo.options.view, "usage");
                fcf.append(options.args, view);
                fcf.append(options.args, view.templateArgs);

                for (var key in a_templateInfo.options) {
                  if (key != "args") options.args[key] = a_templateInfo.options[key];
                }

                fcf.append(options.args, a_templateInfo.options.args);
                fcf.append(options.args, inheritArgs);
                options.args.fcfView = a_templateInfo.options.view;
                if ("value" in a_templateInfo.options) options.args.value = a_templateInfo.options.value;else if ("value" in a_templateInfo.options.view) options.args.value = a_templateInfo.options.view.value;
                if (a_templateInfo.options && a_templateInfo.options.viewArgs) fcf.append(options.args, a_templateInfo.options.viewArgs);
                var mode = a_templateInfo.options.mode ? a_templateInfo.options.mode : "read";
                var template = a_options.state.theme.getView(mode, a_templateInfo.options.view).template;
                options = fcf.append(options, {
                  template: template,
                  request: a_options.request,
                  route: a_options.route,
                  state: a_options.state,
                  update: a_options.update,
                  reqursion: true,
                  onResult: function onResult(a_error, a_template) {
                    if (a_error) {
                      fcf.log.err("Render", a_error);
                      a_act.error(a_error);
                      return;
                    }

                    inlineTemplates[a_key] = a_template.content;
                    a_act.complete();
                  }
                });
                a_options.render.render(options);
              } else {
                a_act.complete();
              }
            } else {
              a_act.complete();
            }
          }).execAC(function () {
            if (templateRender.templates[templateRender.markerHeader]) inlineTemplates[templateRender.markerHeader] = templateRender._header();
          }).execAC(function () {
            if (!fcf.empty(inlineTemplates)) {
              var newResult = "";
              var curPos = 0;
              var endPos = 0;
              var lstPos = 0;

              while (true) {
                curPos = result.indexOf(templateRender.markerPrefix, lstPos);

                if (curPos != -1) {
                  endPos = result.indexOf(templateRender.markerSuffix, curPos);
                  var key = result.substr(curPos, endPos - curPos + templateRender.markerSuffix.length);
                  newResult += result.substr(lstPos, curPos - lstPos);
                  newResult += inlineTemplates[key];
                } else {
                  newResult += result.substr(lstPos);
                  break;
                }

                lstPos = endPos + templateRender.markerSuffix.length;
              }

              result = newResult;
            }

            a_options.onResult(undefined, result);
          });
        })(inlineTemplates);
      };

      this._renderBlock = function (a_options, a_template) {
        var ov = fcf.NDetails.currentTemplate;
        fcf.NDetails.currentTemplate = a_template;
        fcf.scriptExecutor.execute(a_options._innerfcf_currentTemplate, a_options, a_template, a_options.stringNumber);
        fcf.NDetails.currentTemplate = ov;
      };

      this._getRenderingBlocks = function (a_templatePath, a_templateInfo, a_aliases) {
        a_templatePath = fcf.getPath(a_templatePath, a_aliases, true);
        var octothorpePos = a_templatePath.indexOf("+");

        if (octothorpePos !== -1) {
          return [a_templatePath.substr(octothorpePos + 1, a_templatePath.length - octothorpePos - 1)];
        } else {
          return a_templateInfo.defaultBlocks;
        }
      };
    };

    return NDetails.TemplateProcessor;
  }
});
fcf.module({
  name: "fcf:NRender/Template.js",
  dependencies: [],
  module: function module() {
    var NRender = fcf.prepareObject(fcf, "NRender");

    NRender.Template = function (a_options) {
      this.content = fcf.empty(a_options.content) ? "" : a_options.content;
      this.id = a_options.id;
      this.args = a_options.args;
      this.state = a_options.state;
    };

    return NRender.Template;
  }
});
fcf.module({
  name: "fcf:NRender/NDetails/ArgsBuilder.js",
  dependencies: ["fcf:NRender/NDetails/Loader.js", "fcf:NRender/NDetails/TemplateProcessor.js", "fcf:NRender/NDetails/ArgsDependecies.js", "fcf:NRender/Template.js", "fcf:NRender/NDetails/Helper.js", "fcf:NRender/TaskInfo.js"],
  module: function module(Loader, TemplateProcessor, ArgsDependecies, Template, helper, TaskInfo) {
    var NDetails = fcf.prepareObject(fcf, "NRender.NDetails");
    /*
    * @class fcf::NRender::NDetails::ArgsBuilder
    * @brief Класс сборки аргументов шаблона
    **/

    NDetails.ArgsBuilder = function (a_initializeOptions) {
      var self = this;
      this._argsDependecies = new ArgsDependecies({});
      this._templateProcessor = new TemplateProcessor({});
      /*
      * @fn void build(a_options)
      * @params object a_options параметры метода
      *   - string templatePath путь шаблона
      *   - object template данные шаблона
      *   - fcf::NRender::Render render объект рендера
      *   - fcf::NRender::NDetails::Loader  loader объект загрузчика данных о шаблоне
      *   - object state состояние рекурсивного рендеринга
      *   - object inputArgs Аргументы шаблона
      *   - object aliases альясы путей шаблонов
      *   - object projections [optional] объект-карта проекций
      *   - object fcfTransformation параметры транформации запроса к проекции
      *   - string parent
      *   - bool   reqursion Флаг рекурсивного вызова для аргумента шаблона
      *   - function onResult Обратный вызов результата \n
      *               Сигнатура void onResult(fcf::Error a_error, object a_args)
      **/

      this.build = function (a_options) {
        fcf.setContext(a_options.context);
        var fcfId = fcf.genId();
        var normalizeArgs = {};

        for (var key in a_options.args) {
          normalizeArgs[fcf.normalizeObjectAddress(key)] = a_options.args[key];
        }

        var newInputArgs = {};

        for (var key in a_options.inputArgs) {
          var normKey = fcf.normalizeObjectAddress(key);
          newInputArgs[normKey] = a_options.inputArgs[key];
        }

        a_options.inputArgs = newInputArgs;
        fcf.setContext(a_options.context);
        var ti = new TaskInfo({
          owner: this,
          storage: fcf.application.getStorage(),
          route: a_options.route,
          request: a_options.request,
          context: a_options.context,
          _render: a_options.render,
          templatePath: a_options.templatePath,
          template: a_options.template,
          srcArgs: fcf.append(true, {
            '["fcfWrapper"]': true
          }, normalizeArgs),
          fullSrcArgs: fcf.append(true, {
            '["fcfWrapper"]': true
          }, normalizeArgs),
          args: {
            fcfId: fcfId
          },
          reqursion: a_options.reqursion,
          loader: a_options.loader,
          update: a_options.update,
          processedArgs: {},
          processedCounter: 0,
          currentArgType: "system",
          lastArgType: undefined,
          _fcfTransformation: a_options.fcfTransformation,
          projections: a_options.projections ? a_options.projections : fcf.application.getProjections().getProjections(),
          _start: true,
          _firstProcessValue: true,
          _firstProcessTemplate: true,
          inputArgs: a_options.inputArgs,
          aliases: a_options.state.theme.getAliases(),
          state: a_options.state,
          currentTheme: undefined,
          systemArgsIsProcessed: false,
          importants: {},
          _defaultFcfId: fcfId,
          _processFcfAlias: false,
          _processPreFcfChildsArgs: false,
          _processFcfChildsArgs: false,
          _attach: {}
        });

        for (var k in normalizeArgs) {
          if (!fcf.isArg(normalizeArgs[k]) || !normalizeArgs[k].important) continue;
          ti.importants[k] = normalizeArgs[k];
        }

        ti.state.args[fcfId] = ti.args;
        ti.state.sources[fcfId] = ti.fullSrcArgs;

        if (!fcf.empty(a_options.fcfTransformation)) {
          ti.srcArgs["[\"fcfTransformation\"]"] = a_options.fcfTransformation;
          ti.fullSrcArgs["[\"fcfTransformation\"]"] = a_options.fcfTransformation;
        }

        ti.actions = new fcf.Actions({
          onError: function onError(a_error) {
            a_options.onResult(a_error, undefined);
          }
        });

        for (var key in a_options.inputArgs) {
          ti.srcArgs[key] = a_options.inputArgs[key];
          ti.fullSrcArgs[key] = a_options.inputArgs[key];
        }

        for (var key in ti.srcArgs) {
          if (!fcf.isArg(ti.srcArgs[key]) || !("attach" in ti.srcArgs[key])) continue;
          var arg = fcf.normalizeObjectAddress(ti.srcArgs[key].attach.arg);
          if (!(arg in ti.srcArgs)) continue;
          if (!fcf.isArg(ti.srcArgs[arg])) ti.srcArgs[arg] = fcf.arg("value", {
            value: ti.srcArgs[arg]
          });
          if (!Array.isArray(ti.srcArgs[arg].dependencies)) ti.srcArgs[arg].dependencies = [];
          ti.srcArgs[arg].dependencies.push(key);
          if (!ti._attach[arg]) ti._attach[arg] = [];

          ti._attach[arg].push(key);
        }

        function clComplete() {
          if (ti._defaultFcfId != ti.args.fcfId) {//delete ti.state.args[fcfId];
            //delete ti.state.sources[fcfId];
          }

          if (fcf.isServer()) {
            if (ti.request && ti.args.fcfId) {
              if (Array.isArray(ti.args.fcfInclude)) {
                for (var i = 0; i < ti.args.fcfInclude.length; ++i) {
                  var incl = ti.args.fcfInclude[i];
                  ti.state.include[incl] = incl;
                }
              }

              if (ti.args.fcfWrapper && (ti.args.fcfStorage === undefined || ti.args.fcfStorage)) {
                ti.state.renderRestore[ti.args.fcfId] = {};
                delete ti.fullSrcArgs['["fcfChildsArgs"]'];
                fcf.append(ti.state.renderRestore[ti.args.fcfId], ti.fullSrcArgs);
                fcf.each(a_options.inputArgs, function (a_key, a_value) {
                  if (a_key == '["fcfChildsArgs"]') return;
                  ti.state.renderRestore[ti.args.fcfId][a_key] = a_value;
                });
                var data = {};
                fcf.each(ti.fullSrcArgs, function (a_key, a_value) {
                  if (a_key == '["fcfChildsArgs"]') return;
                  if (fcf.isArg(a_value) && a_value.type != "value" && a_value.type != "reference" && a_value.type != "programmable") return;
                  var ptrData = fcf.resolveEx(data, a_key, true);
                  ptrData.object[ptrData.key] = fcf.resolve(ti.args, a_key);
                });
                ti.state.renderStorage[ti.args.fcfId] = data;
              }
            }
          } else {
            if (ti.args.fcfWrapper && (ti.args.fcfStorage === undefined || ti.args.fcfStorage)) {
              if (!ti.update && !fcf.getWrapper(ti.args.fcfId)) {
                fcf.each(a_options.inputArgs, function (a_key, a_value) {
                  if (a_key == '["fcfChildsArgs"]') return;
                  fcf.application.getLocalData().setSourceItem(ti.args.fcfId, a_key, a_value);
                });
              }

              fcf.each(ti.fullSrcArgs, function (a_key, a_value) {
                if (fcf.isArg(a_value) && a_value.type != "value" && a_value.type != "reference" && a_value.type != "programmable") return;
                if (a_key == '["fcfChildsArgs"]') return;
                var ptr = fcf.resolveEx(ti.args, a_key);

                if (ptr.object) {
                  fcf.application.getLocalData().setOriginItem(ti.args.fcfId, a_key, ptr.object[ptr.key]);
                  if (ti.update) fcf.application.getLocalData().setObject(ti.args.fcfId, {});
                }
              });
            }
          }

          if (ti.request && ti.args.fcfId) {
            if (!fcf.empty(ti.args.fcfTheme)) {
              if (!ti.reqursion) {
                var newTheme = fcf.application.getThemes().getTheme(ti.args.fcfTheme);
                if (newTheme) ti.state.theme = newTheme;
              }

              ti.state.themes[ti.args.fcfTheme] = ti.args.fcfTheme;
            }
          }

          try {
            helper.callHook(ti.template, "hookAfterBuild", ti);
          } catch (e) {
            a_act.error(e);
            return;
          }

          ti.actions.exec(function (a_act) {
            a_options.onResult(undefined, ti.args, ti.fullSrcArgs);
            a_act.complete();
          });
        }

        ;

        try {
          helper.callHook(ti.template, "hookBeforeBuild", ti);
        } catch (e) {
          ti.actions.error(e);
          return;
        }

        ;

        self._processedArgs(ti, clComplete);
      };

      this._callHookBeforeArgument = function (a_taskInfo, a_argPath) {
        if (!a_taskInfo._processedHooksBeforeArgument) a_taskInfo._processedHooksBeforeArgument = {};
        if (a_argPath in a_taskInfo._processedHooksBeforeArgument) return;
        a_taskInfo._processedHooksBeforeArgument[a_argPath] = true;
        helper.callHookBeforeArgument(a_taskInfo.template, a_argPath, a_taskInfo);
      };

      this._callProgrammableArgument = function (a_taskInfo, a_argPath) {
        if (!a_taskInfo._processedHooksProgrammableArguments) a_taskInfo._processedHooksProgrammableArguments = {};
        if (a_argPath in a_taskInfo._processedHooksProgrammableArguments) return;
        a_taskInfo._processedHooksProgrammableArguments[a_argPath] = true;
        helper.callHookProgramableArgument(a_taskInfo.template, a_argPath, a_taskInfo);
      };

      this._callHookAfterArgument = function (a_taskInfo, a_argPath) {
        if (!a_taskInfo._processedHooksAfterArgument) a_taskInfo._processedHooksAfterArgument = {};
        if (a_argPath in a_taskInfo._processedHooksAfterArgument) return;
        a_taskInfo._processedHooksAfterArgument[a_argPath] = true;
        helper.callHookAfterArgument(a_taskInfo.template, a_argPath, a_taskInfo);
      };

      this.getSystemArg = function (a_taskInfo) {
        return this._getNextArg(a_taskInfo, "system");
      };

      this._getLevels = function () {
        return ["system", "reference", "value", "template", "view", "programmable", "*"];
      };

      this.getArg = function (a_taskInfo) {
        var types = this._getLevels();

        var typeIndex = fcf.find(types, a_taskInfo.currentArgType);

        while (true) {
          var argPath = this._getNextArg(a_taskInfo, a_taskInfo.currentArgType);

          if (argPath) {
            a_taskInfo.lastArgType = a_taskInfo.currentArgType;
            return argPath;
          } else {
            if (a_taskInfo.lastArgType != a_taskInfo.currentArgType) {
              ++typeIndex;
              if (typeIndex >= types.length) return;
              a_taskInfo.lastArgType = a_taskInfo.currentArgType;
              a_taskInfo.currentArgType = types[typeIndex];
            } else if (a_taskInfo.lastArgType == a_taskInfo.currentArgType && a_taskInfo.currentArgType == "system") {
              ++typeIndex;
              if (typeIndex >= types.length) return;
              a_taskInfo.lastArgType = a_taskInfo.currentArgType;
              a_taskInfo.currentArgType = types[typeIndex];
            } else {
              a_taskInfo.lastArgType = a_taskInfo.currentArgType;
              a_taskInfo.currentArgType = types[0];
            }
          }
        }
      };

      this._processedArgs = function (a_taskInfo, a_cbComplete) {
        function processArg() {
          if (++a_taskInfo.state.reqursionCounter < 300) {
            processArgUnsafe();
          } else {
            a_taskInfo.state.reqursionCounter = 0;
            setTimeout(processArgUnsafe, 0);
          }
        }

        function processArgUnsafe() {
          var argPath = undefined;

          if (!a_taskInfo.systemArgsIsProcessed) {
            argPath = self.getSystemArg(a_taskInfo);

            if (!argPath) {
              if (!a_taskInfo.currentTheme && a_taskInfo.args.fcfTheme) {
                a_taskInfo.currentTheme = a_taskInfo.args.fcfTheme;
                var theme = fcf.application.getThemes().getTheme(a_taskInfo.currentTheme);
                a_taskInfo.state.theme = theme;
                a_taskInfo.aliases = theme.getAliases();
              }

              a_taskInfo.systemArgsIsProcessed = true;
              helper.callHook(a_taskInfo.template, "hookAfterSystemBuild", a_taskInfo);
            }
          }

          if (a_taskInfo.systemArgsIsProcessed) {
            argPath = self.getArg(a_taskInfo);
          }

          if (argPath == "[\"fcfChildsArgs\"]") {
            a_taskInfo._processPreFcfChildsArgs = true;
          } else if (a_taskInfo._processPreFcfChildsArgs && !a_taskInfo._processFcfChildsArgs) {
            a_taskInfo._processFcfChildsArgs = true; // if (a_taskInfo.args.fcfChildsArgs &&
            //     a_taskInfo.args.fcfChildsArgs.args)
            // {
            //   fcf.append(a_taskInfo.srcArgs, a_taskInfo.args.fcfChildsArgs.args);
            //   fcf.append(a_taskInfo.fullSrcArgs, a_taskInfo.args.fcfChildsArgs.args);
            // }
          }

          if (!argPath) {
            a_taskInfo.actions.execAC(function () {
              a_cbComplete();
            });
            return;
          }

          try {
            self._callHookBeforeArgument(a_taskInfo, argPath);
          } catch (e) {
            a_act.error(e);
            return;
          }

          function processing(a_taskInfo, a_argContainer, a_argName, a_cb) {
            a_taskInfo.actions.exec(function (a_act) {
              if (fcf.isArg(a_argContainer[a_argName])) a_argContainer[a_argName] = self._tokenizeArg(a_argContainer[a_argName], a_taskInfo.args, a_taskInfo);

              self._processedInnerArgs(argPath, a_argContainer[a_argName], a_taskInfo, function (a_error) {
                if (a_error) {
                  a_taskInfo.actions.error(a_error);
                  return;
                }

                self._processedArg(argPath, a_argContainer[a_argName], a_taskInfo, function (a_error, a_data) {
                  if (a_error) {
                    a_taskInfo.actions.error(a_error);
                  } else {
                    if (a_data !== undefined) {
                      var ptr = fcf.resolveEx(a_taskInfo.args, argPath, true);
                      ptr.object[ptr.key] = a_data;
                    }

                    a_cb();
                  }
                });
              });

              a_act.complete();
            });
          }

          function completeProcessing() {
            delete a_taskInfo.srcArgs[argPath];
            a_taskInfo.processedArgs[argPath] = true;

            if (argPath == "[\"fcfTransformation\"]") {
              a_taskInfo._fcfTransformation = a_taskInfo.args.fcfTransformation;
              a_taskInfo.projections = fcf.application.getProjections().transformation(a_taskInfo.args.fcfTransformation).getProjections();
            } else if (argPath == "[\"fcfId\"]") {
              a_taskInfo.state.args[a_taskInfo.args.fcfId] = a_taskInfo.args;
              a_taskInfo.state.sources[a_taskInfo.args.fcfId] = a_taskInfo.fullSrcArgs;
            } else if (argPath == "[\"fcfDependencies\"]") {
              if (typeof a_taskInfo.args.fcfDependencies == "object") {
                for (var key in a_taskInfo.args.fcfDependencies) {
                  var normKey = fcf.normalizeObjectAddress(key);
                  var deps = a_taskInfo.args.fcfDependencies[key];
                  if (!(normKey in a_taskInfo.srcArgs)) continue;

                  if (!fcf.isArg(a_taskInfo.srcArgs[normKey])) {
                    a_taskInfo.srcArgs[normKey] = fcf.arg("value", {
                      value: a_taskInfo.srcArgs[normKey]
                    });
                  }

                  if (!a_taskInfo.srcArgs[normKey].dependencies) a_taskInfo.srcArgs[normKey].dependencies = [];
                  deps = Array.isArray(deps) ? deps : [deps];
                  fcf.append(a_taskInfo.srcArgs[normKey].dependencies, deps);
                }
              }
            }

            if (argPath in a_taskInfo._attach) {
              for (var i = 0; i < a_taskInfo._attach[argPath].length; ++i) {
                var srcPath = a_taskInfo._attach[argPath][i];
                var srcParams = a_taskInfo.fullSrcArgs[srcPath].attach;
                var srcData = fcf.resolve(a_taskInfo.args, srcPath);
                var dstDataPtr = fcf.resolveEx(a_taskInfo.args, argPath);
                dstDataPtr.object[dstDataPtr.key] = fcf.merge(dstDataPtr.object[dstDataPtr.key], srcData, srcParams);
              }
            }

            try {
              self._callHookAfterArgument(a_taskInfo, argPath);
            } catch (e) {
              a_taskInfo.actions.error(e);
              return;
            }

            a_taskInfo.actions.execAC(function () {
              processArg();
            });
          }

          var enableImportant = fcf.isArg(a_taskInfo.importants[argPath]) && a_taskInfo.importants[argPath].important && (!fcf.isArg(a_taskInfo.srcArgs[argPath]) || !a_taskInfo.srcArgs[argPath].important);
          processing(a_taskInfo, a_taskInfo.srcArgs, argPath, function () {
            if (enableImportant) {
              processing(a_taskInfo, a_taskInfo.importants, argPath, function () {
                completeProcessing();
              });
            } else {
              completeProcessing();
            }
          });
        }

        processArg();
      };

      this._processedInnerArgs = function (a_argPath, a_srcArg, a_taskInfo, a_cb) {
        if (a_argPath == '["fcfChildsArgs"]') {
          a_cb();
          return;
        }

        function clFindInnerArg(a_value, a_path, a_result) {
          if (!a_result) a_result = [];
          fcf.each(a_value, function (a_key, a_v) {
            var path = fcf.append([], a_path);
            path.push(a_key);

            if (fcf.isArg(a_v)) {
              a_value[a_key] = self._tokenizeArg(a_v, a_taskInfo.args, a_taskInfo);
              var skip = fcf.isArg(a_srcArg) && (a_srcArg.type == "template" || a_srcArg.type == "view") && a_v.type == "reference";
              if (!skip) a_result.push(path);
            } else if (typeof a_v == "object") {
              clFindInnerArg(a_v, path, a_result);
            }
          });
          return a_result;
        }

        function clNormalizePaths(a_arrPaths) {
          fcf.each(a_arrPaths, function (a_key, a_value) {
            var line = "";

            for (var i = 0; i < a_value.length; ++i) {
              line += "[\"" + fcf.escapeQuotes(a_value[i]) + "\"]";
            }

            a_arrPaths[a_key] = line;
          });
          return a_arrPaths;
        }

        var innerSrcArgs = clNormalizePaths(clFindInnerArg(a_srcArg));
        new fcf.Actions({
          onError: function onError(a_error) {
            a_cb(a_error);
          }
        }).each(innerSrcArgs, function (a_act, a_key, a_value) {
          var ptr = fcf.resolveEx(a_srcArg, a_value);
          var innerSrcArg = ptr.object[ptr.key];

          self._processedArg(a_argPath + "->" + a_key, innerSrcArg, a_taskInfo, function (a_error, a_data) {
            if (a_error) {
              a_act.error(a_error);
              return;
            }

            var ptr = fcf.resolveEx(a_srcArg, a_value);
            ptr.object[ptr.key] = a_data;
            a_act.complete();
          });
        }).execAC(function () {
          a_cb();
        });
      };

      this._processedArg = function (a_argPath, a_srcArg, a_taskInfo, a_cb) {
        // already processed by the hook
        if (a_srcArg === undefined) {
          a_cb(undefined);
          return;
        }

        fcf.setContext(a_taskInfo.context);

        if (!fcf.isArg(a_srcArg) || a_srcArg.type == "value") {
          a_cb(undefined, self._processValue(a_srcArg, a_taskInfo));
        } else if (a_srcArg.type == "reference") {
          self._processReference(a_srcArg, a_taskInfo, a_cb);
        } else if (a_srcArg.type == "template") {
          self._processTemplate(a_argPath, a_srcArg, a_taskInfo, a_cb);
        } else if (a_srcArg.type == "view") {
          self._processView(a_argPath, a_srcArg, a_taskInfo, a_cb);
        } else if (a_srcArg.type == "programmable" && a_argPath) {
          self._callProgrammableArgument(a_taskInfo, a_argPath);

          a_taskInfo.actions.execAC(function () {
            a_cb(undefined);
          });
        } else {
          a_cb(undefined);
        }
      };

      this._processReference = function (a_srcArg, a_taskInfo, a_cb) {
        var data = undefined;

        if (!fcf.isServer()) {
          var wrp = fcf.getWrapper(a_srcArg.id);
          if (wrp) data = wrp.getArg(a_srcArg.arg);else if (data === undefined) data = fcf.resolve(a_taskInfo.state.args[a_srcArg.id], a_srcArg.arg);
        } else {
          data = fcf.resolve(a_taskInfo.state.args[a_srcArg.id], a_srcArg.arg);
        }

        a_cb(undefined, data);
      };

      this._processTemplate = function (a_argPath, a_srcArg, a_taskInfo, a_cb) {
        this._processTemplateItem(0, a_argPath, a_srcArg.template, a_srcArg.args, a_taskInfo, function (a_error, a_content) {
          if (a_error) {
            a_cb(a_error);
            return;
          }

          a_cb(undefined, a_content);
        });
      };

      this._processTemplateItem = function (a_callIndex, a_argPath, a_template, a_inputArgs, a_taskInfo, a_cb) {
        var rootTemplateFile = a_taskInfo.templatePath.split("+")[0];
        if (a_template.indexOf("+") == 0) var templatePath = rootTemplateFile + "+" + a_template.substr(1);else var templatePath = a_template;
        var templateFile = templatePath.split("+")[0];
        var fullPathRootTemplateFile = fcf.getPath(rootTemplateFile);
        var fullPathTemplateFile = fcf.getPath(templateFile);
        inputArgs = fcf.append(true, {}, a_inputArgs); //delete inputArgs.fcfId;
        //delete inputArgs.fcfParent;

        if (a_taskInfo.args.fcfWrapper) inputArgs.fcfParent = a_taskInfo.args.fcfId;
        helper.appendChildInfo(inputArgs, a_taskInfo.args, a_taskInfo.args.fcfChildsArgs);
        inputArgs.fcfCP = "tmpl:" + a_argPath + ":" + a_callIndex;

        a_taskInfo._render.render({
          template: templatePath,
          theme: a_taskInfo.state.theme.getName(),
          route: a_taskInfo.route,
          context: a_taskInfo.context,
          state: a_taskInfo.state,
          request: a_taskInfo.request,
          update: a_taskInfo.update,
          reqursion: true,
          projections: a_taskInfo.projections,
          fcfTransformation: a_taskInfo._fcfTransformation,
          args: fcf.unescapeObject(inputArgs),
          onResult: function onResult(a_error, a_template) {
            if (a_error) {
              a_cb(a_error);
              return;
            }

            a_cb(undefined, a_template.content);
          }
        });
      };

      this._processView = function (a_argPath, a_srcArg, a_taskInfo, a_cb) {
        var view = a_srcArg.view;
        var mode = a_srcArg.fcfMode ? a_srcArg.fcfMode : a_taskInfo.args.fcfMode ? a_taskInfo.args.fcfMode : "read";
        var template = a_taskInfo.state.theme.getView(mode, a_srcArg.view).template;
        var view = fcf.buildModeObject(mode, a_srcArg.view, "usage");
        var templateArgs = fcf.append(true, {}, view);
        fcf.append(templateArgs, a_srcArg.view.templateArgs);
        templateArgs.record = a_srcArg.record;
        templateArgs.fcfParent = a_taskInfo.args.fcfWrapper ? a_taskInfo.args.fcfId : undefined;
        if (a_taskInfo.args.fcfMode) templateArgs.fcfMode = a_taskInfo.args.fcfMode;
        templateArgs.fcfKey = a_taskInfo.args.fcfKey;
        templateArgs.view = a_srcArg.view;
        templateArgs.fcfClass = a_taskInfo.args.fcfChildClass;
        templateArgs.fcfCP = "view:" + a_argPath;
        templateArgs.value = fcf.isArg(a_srcArg.value) ? fcf.unescapeObject(a_srcArg.value) : !fcf.empty(a_srcArg.value) ? fcf.arg("value", {
          value: fcf.unescapeObject(a_srcArg.value)
        }) : fcf.isArg(view.value) ? fcf.unescapeObject(view.value) : !fcf.empty(view.value) ? fcf.arg("value", {
          value: fcf.unescapeObject(view.value)
        }) : fcf.isArg(view["default"]) ? fcf.unescapeObject(view["default"]) : !fcf.empty(view["default"]) ? fcf.arg("value", {
          value: fcf.unescapeObject(view["default"])
        }) : undefined;
        helper.appendChildInfo(templateArgs, templateArgs, a_taskInfo.args.fcfChildsArgs);

        a_taskInfo._render.render({
          template: template,
          state: a_taskInfo.state,
          theme: a_taskInfo.state.theme.getName(),
          route: a_taskInfo.route,
          projections: a_taskInfo.projections,
          fcfTransformation: a_taskInfo._fcfTransformation,
          request: a_taskInfo.request,
          args: templateArgs,
          context: a_taskInfo.context,
          update: a_taskInfo.update,
          reqursion: true,
          onResult: function onResult(a_error, a_template) {
            if (a_error) {
              a_cb(a_error);
              return;
            }

            a_cb(undefined, a_srcArg.fullResult ? a_template : a_template.content);
          }
        });
      };

      this._normalizeSrcArgs = function (a_srcArgs) {
        var result = {};

        for (var key in a_srcArgs) {
          result[fcf.normalizeObjectAddress(key)] = a_srcArgs[key];
        }

        return result;
      };

      this.isPreparedValue = function (a_value) {
        if (typeof a_value == "string") {
          var reg = new RegExp("([^\\\\][@#$]{{)|(^[@#$]{{)");
          var m = a_value.match(reg);
          return fcf.empty(m);
        } else if (typeof a_value == "object") {
          var res = true;
          fcf.foreach(a_value, function (k, v) {
            res &= this.isPreparedValue(v);
          });
          return res;
        }

        return true;
      };

      this._processValue = function (a_srcArg, a_taskInfo) {
        var isex = fcf.isArg(a_srcArg);
        var value = isex ? a_srcArg.value : a_srcArg;
        var needDefault = false;

        if (typeof value === "string") {
          needDefault = value.indexOf("${{") != -1 || value.indexOf("#{{") != -1 || value.indexOf("@{{") != -1;
        }

        if ((fcf.empty(value) || needDefault) && isex && "default" in a_srcArg) {
          value = a_srcArg["default"];
          needDefault = false;
        }

        if ((fcf.empty(value) || needDefault) && isex && Array.isArray(a_srcArg.defaults)) {
          var defaults = a_srcArg.defaults;

          for (var i = 0; i < defaults.length; ++i) {
            if (!fcf.empty(defaults[i]) && this.isPreparedValue(defaults[i])) {
              value = defaults[i];
              break;
            }
          }
        }

        if (isex && typeof a_srcArg.merge == "object") {
          var merge = fcf.isEnumerable(a_srcArg.merge) ? a_srcArg.merge : [a_srcArg.merge];

          for (var i = 0; i < merge.length; ++i) {
            value = fcf.merge(value, merge[i].value, merge[i].options);
          }
        }

        return value;
      };

      this._tokenizeArg = function (a_srcArg, a_args, a_taskInfo) {
        var args = {
          args: a_args,
          source: a_srcArg,
          route: a_taskInfo.route,
          projections: fcf.application.getProjections().getProjections()
        };
        var result = fcf.tokenizeObject(a_srcArg, args, true);
        return result;
      };

      this._getNextArg = function (a_taskInfo, a_type) {
        for (var key in a_taskInfo.srcArgs) {
          if (a_type == "system") {
            if (key.indexOf("[\"fcf") !== 0) continue;
          } else {
            var src = fcf.isArg(a_taskInfo.srcArgs[key]) ? a_taskInfo.srcArgs[key] : fcf.arg("value");
            var level = src.level ? src.level : src.type;
            var typeMatching = a_type == level;
            if (!typeMatching && a_type != "*") continue;
          }

          var important = fcf.isArg(a_taskInfo.importants[key]) ? a_taskInfo.importants[key] : fcf.arg("value");
          var deps = [];

          if (fcf.isArg(a_taskInfo.srcArgs[key])) {
            deps = this._getTokenizeDependencies(a_taskInfo, a_taskInfo.srcArgs[key]);
            fcf.append(deps, a_taskInfo.srcArgs[key].dependencies);
          }

          if (fcf.isArg(a_taskInfo.importants[key])) {
            fcf.append(deps, this._getTokenizeDependencies(a_taskInfo, a_taskInfo.importants[key]));
            fcf.append(deps, a_taskInfo.importants[key].dependencies);
          }

          var inwaiting = false;

          for (var i = 0; i < deps.length; ++i) {
            inwaiting |= this._checkWaiting(deps[i], a_taskInfo);
            if (inwaiting) break;
          }

          if (inwaiting) continue;

          if (a_type != "*") {
            if (key == ["[\"fcfChildsArgs\"]"] && a_taskInfo.fullSrcArgs["[\"fcfCP\"]"]) {
              inwaiting |= this._checkWaiting("args." + ["fcfCP"], a_taskInfo);
              if (inwaiting) continue;
            }
          }

          return key;
        }

        if (a_type == "*") {
          for (var key in a_taskInfo.srcArgs) {
            return key;
          }
        }

        return;
      };

      this._checkWaiting = function (a_path, a_taskInfo) {
        a_path = fcf.normalizeObjectAddress(a_path);
        if (a_path in a_taskInfo.processedArgs) return false;
        var ptr = fcf.resolveEx(a_taskInfo.srcArgs, a_path);
        if (ptr.object && ptr.key in ptr.object) return false;
        return true;
      };

      this._getTokenizeDependencies = function (a_taskInfo, a_srcArgs, _a_dst) {
        var isRoot = false;

        if (_a_dst === undefined) {
          _a_dst = {};
          isRoot = true;
        }

        for (var k in a_srcArgs) {
          if (typeof a_srcArgs[k] === "string") {
            if (a_srcArgs[k].indexOf("#{{") == 0 && a_srcArgs[k].indexOf("}}#") == a_srcArgs[k].length - 3) {
              var addr = fcf.trim(a_srcArgs[k].substr(3, a_srcArgs[k].length - 6));
              var addrArr = fcf.parseObjectAddress(addr);
              if (addrArr[0] != "router") _a_dst[addr] = true;
            } else {
              var keys = fcf.getVariablesString(a_srcArgs[k]);

              for (var i = 0; i < keys.length; ++i) {
                var addrArr = fcf.parseObjectAddress(keys[i]);
                if (addrArr[0] != "router") _a_dst[keys[i]] = true;
              }
            }
          } else if (typeof a_srcArgs[k] === "object") {
            this._getTokenizeDependencies(a_taskInfo, a_srcArgs[k], _a_dst);
          }
        }

        if (fcf.isArg(a_srcArgs) && a_srcArgs.type == "reference") {
          if (a_srcArgs.id == a_taskInfo.args.fcfId || a_srcArgs.id == "${{args.fcfId}}$" || a_srcArgs.id == "@{{args.fcfId}}@") {
            var arg = fcf.parseObjectAddress(a_srcArgs.arg)[0];
            if (arg !== undefined) _a_dst[arg] = true;
          }
        }

        if (isRoot) {
          var result = [];

          for (var k in _a_dst) {
            result.push(k);
          }

          return result;
        }
      };
    };

    return NDetails.ArgsBuilder;
  }
});
/**
* @namespace fcf::NRender
*lng_en @brief Rendering namespace
*lng_ru @brief Пространство имен рендеринга
**/

fcf.module({
  name: "fcf:NRender/Render.js",
  dependencies: ["fcf:NRender/NDetails/Loader.js", "fcf:NRender/NDetails/TemplateProcessor.js", "fcf:NRender/NDetails/ArgsDependecies.js", "fcf:NRender/NDetails/ArgsBuilder.js", "fcf:NRender/Template.js"],
  module: function module(Loader, TemplateProcessor, ArgsDependecies, ArgsBuilder, Template) {
    var NRender = fcf.prepareObject(fcf, "NRender");

    NRender.Render = function (a_initializeOptions) {
      var self = this;
      this._options = fcf.append({}, a_initializeOptions);
      this._options.template = this._options.template;
      this._loader = new Loader();
      this._argsDependecies = new ArgsDependecies({});
      this._defaultRouteInfo = a_initializeOptions.routeInfo ? a_initializeOptions.routeInfo : {
        args: {}
      };

      this.setFileСaching = function (a_value) {
        this._options.fileСaching = a_value;

        this._loader.setSettings({
          fileСaching: a_value
        });
      };
      /*
      * @fn void render(object a_options)
      * @brief Выполняет рендеринг шаблона
      * @param object a_options
      *     - string template
      *     - bool   external флаг внешнего запорса на отрисовку шаблона
      *     - object args [optional]
      *     - bool   update [optional] флаг обновления повторной отрисовки на клиенте
      *     - object state внутренняя информация рекурсивного рендеринга
      *     - function onResult(a_error, a_template)
      **/


      this.render = function (a_options) {
        if (a_options.context) fcf.setContext(a_options.context);
        argsBuilder = new ArgsBuilder({});
        templateProcessor = new TemplateProcessor({
          render: this,
          loader: this._loader
        });
        var needOnServer = !fcf.isServer() && fcf.getContext().get("needBabel");
        var breakExecution = needOnServer;
        var part = a_options.template.split("+")[1] ? a_options.template.split("+")[1] : "";
        var resultContext = "";
        var fullTemplate = undefined;
        var rawTemplate = undefined;
        var resultArgs = {};
        var resultSources = {};
        var srcArgs = {};
        var srcArgsDependecies = {};
        var defaultThemeName = a_options.theme ? a_options.theme : "defaultTheme";
        var defaultTheme = fcf.application.getThemes().getTheme(defaultThemeName, true);
        var externalArgs = typeof a_options.externalArgs == "object" ? a_options.externalArgs : {};
        var isExternalEmpty = true;

        for (var _k2 in externalArgs) {
          externalArgs[_k2].__innerFcfPostRemove = true;
          isExternalEmpty = false;
        }

        var isRootCall = !a_options.state;
        var state = a_options.state ? a_options.state : {
          theme: defaultTheme,
          defaultTheme: defaultTheme,
          themes: {},
          include: {},
          renderRestore: {},
          renderStorage: {},
          reqursionCounter: 0,
          args: externalArgs,
          sources: {}
        };
        var action = new fcf.Actions();
        var theme = undefined; //loading template

        action.append(function (a_act) {
          if (needOnServer) {
            a_act.complete();
            return;
          }

          theme = state.theme;

          self._loader.load(a_options.template, state, function (a_error, a_fullTemplate) {
            if (a_error) {
              a_act.error(a_error);
              return;
            }

            fullTemplate = a_fullTemplate;
            rawTemplate = fullTemplate.templates[part];

            if (!rawTemplate) {
              a_act.error(new fcf.Exception("ERROR_RENDER_TEMPLATE_NOT_FOUND", {
                template: a_options.template
              }));
              return;
            }

            a_act.complete();
          });
        }); // Detect serverOnly

        action.append(function (a_act) {
          if (needOnServer || fullTemplate.options.serverOnly && !fcf.isServer()) {
            breakExecution = true;
            fcf.loadObject({
              path: "@url:fcfRender",
              post: {
                template: a_options.template,
                args: a_options.args,
                update: a_options.update,
                url: window.location.href,
                externalArgs: a_options.externalArgs
              },
              onResult: function onResult(a_error, a_response) {
                if (a_error) {
                  a_act.error(a_error);
                  return;
                }

                var resultTemplate = new Template({
                  content: a_response.content,
                  id: a_response.id,
                  args: a_response.args,
                  state: a_response.state
                });
                fcf.append(state.args, a_response.state.args);
                fcf.append(state.sources, a_response.state.sources);

                if (!resultTemplate.args.fcfError) {
                  if (a_options.onResult) a_options.onResult(undefined, resultTemplate);
                  a_act.complete(resultTemplate);
                } else {
                  a_act.error(resultTemplate.args.fcfError);
                }
              }
            });
          } else {
            a_act.complete();
          }
        }); //build arguments

        action.append(function (a_act, a_result) {
          if (breakExecution) {
            a_act.complete(a_result);
            return;
          }

          var args = typeof a_options.args == "object" ? a_options.args : {};
          argsBuilder.build({
            render: self,
            request: a_options.request,
            context: a_options.context ? a_options.context : fcf.getContext(),
            state: state,
            reqursion: a_options.reqursion,
            templatePath: a_options.template,
            route: a_options.route ? a_options.route : self._defaultRouteInfo,
            loader: self._loader,
            projections: a_options.projections,
            args: rawTemplate.arguments,
            template: rawTemplate,
            update: a_options.update,
            inputArgs: args,
            onResult: function onResult(a_error, a_args, a_sources) {
              if (a_error) {
                a_act.error(a_error);
                return;
              }

              resultArgs = a_args;
              resultSources = a_sources;
              a_act.complete();
            }
          });
        }); //build template

        action.append(function (a_act, a_result) {
          if (breakExecution) {
            a_act.complete(a_result);
            return;
          }

          var params = {
            render: self,
            request: a_options.request,
            context: a_options.context ? a_options.context : fcf.getContext(),
            template: a_options.template,
            rawTemplate: rawTemplate,
            route: a_options.route ? a_options.route : self._defaultRouteInfo,
            request: a_options.request,
            args: resultArgs,
            sources: resultSources,
            projections: a_options.projections,
            state: state,
            loader: self._loader,
            onResult: function onResult(a_error, a_content) {
              if (a_error) {
                a_act.error(a_error);
                return;
              }

              resultContext = a_content;
              a_act.complete();
            }
          };
          templateProcessor.build(params);
        }); //create result template

        action.append(function (a_act, a_result) {
          if (breakExecution) {
            a_act.complete(a_result);
            return;
          }

          if (!isExternalEmpty && isRootCall) {
            var rm = [];

            for (var _k3 in state.args) {
              if (state.args[_k3].__innerFcfPostRemove) rm.push(_k3);
            }

            for (var i = 0; i < rm.length; ++i) {
              delete state.args[rm[i]];
            }
          }

          var args = resultArgs;
          delete args.fcfChildsArgs;
          var resultTemplate = new Template({
            content: resultContext,
            id: resultArgs.fcfId,
            args: args,
            state: {
              args: state.args,
              sources: state.sources
            }
          });

          if (!resultTemplate.args.fcfError) {
            if (a_options.onResult) a_options.onResult(undefined, resultTemplate);
            a_act.complete(resultTemplate);
          } else {
            a_act.error(resultTemplate.args.fcfError);
          }
        });
        action["catch"](function (a_error) {
          if (a_options.onResult) a_options.onResult(a_error, new Template({}));
        });
        action.startup();
        return action;
      };

      this.getLoader = function () {
        return this._loader;
      };

      this.getStorage = function () {
        return this._options.storage;
      };

      this._normalizeArgsKeys = function (a_args) {
        var res = {};

        for (var k in a_args) {
          res[fcf.normalizeObjectAddress(k)] = a_args[k];
        }

        return res;
      };
    };

    return NRender.Render;
  }
});

if (fcf.isServer()) {
  var fs = require("fs");

  var modulePath = require("path");
}

fcf.module({
  name: "fcf:NFSQL/Projections.js",
  dependencies: [],
  module: function module() {
    fcf.prepareObject(fcf, "NFSQL");
    fcf.addException("ERROR_PROJECTION_UNKNOWN_JOIN_FIELD", "Incorrect '${{projection}}$' projection is specified in the join property for the ${{field}}$ field");

    fcf.NFSQL.Projections = function () {
      var self = this;
      this._descs = {}; // Нужен только для загрузки файлов как флаг

      this._reloadDirs = {};
      this._pendingExtends = {};
      this._pendingJoin = {};

      this.load = function (a_projectionName, a_cb) {
        if (a_projectionName in this._descs) {
          a_cb(undefined, this._descs[a_projectionName]);
          return;
        }

        var path = fcf.settings.routeAliases.fsql + (fcf.settings.routeAliases.fsql.indexOf('?') == -1 ? '?' : '&') + 'projection=' + (fcf.empty(a_projectionName) ? '' : a_projectionName);
        fcf.load({
          path: path,
          onResult: function onResult(a_error, a_data) {
            if (a_error) {
              a_cb(a_error, undefined);
              return;
            }

            try {
              var data = fcf.scriptExecutor.parse(a_data, {}, path, 0);

              if (data.error) {
                a_cb(data.error, undefined);
                return;
              }

              for (var i = 0; i < data.projections.length; ++i) {
                self.appendProjectionStruct(data.projections[i]);
              }

              a_cb(undefined, self.get(a_projectionName));
            } catch (error) {
              a_cb(error, undefined);
            }
          }
        });
      };

      this.transformation = function (a_transformation) {
        var projections = this.clone();
        var projectionsMap = projections.getProjections();

        for (var alias in projectionsMap) {
          var isFirstTransformation = true;

          for (var transformationName in a_transformation) {
            if (!projectionsMap[alias].transformation) continue;
            if (!projectionsMap[alias].transformation[transformationName]) continue;
            if (isFirstTransformation) projectionsMap[alias] = fcf.append(true, {}, projectionsMap[alias]);
            isFirstTransformation = false;
            var transformationItems = fcf.tokenizeObject(projectionsMap[alias].transformation[transformationName], a_transformation[transformationName]);
            if (!Array.isArray(transformationItems)) continue;

            for (var i = 0; i < transformationItems.length; ++i) {
              var item = transformationItems[i];
              if (!item.source) continue;
              var ptr = fcf.resolveEx(projectionsMap[alias], item.source, true);
              ptr.object[ptr.key] = item.value;
            }
          }
        }

        return projections;
      };

      this.loadFromDirectory = function (a_path, a_recursion) {
        if (!a_recursion) this._reloadDirs[a_path] = true;
        var files = fs.readdirSync(a_path);

        for (var key in files) {
          var fpath = a_path + "/" + files[key];

          try {
            var isDir;

            try {
              var stats = fs.statSync(fpath);
              isDir = stats.isDirectory();
            } catch (e) {
              continue;
            }

            if (isDir) {
              this.loadFromDirectory(fpath, a_recursion);
            } else {
              if (fpath.length < 12) continue;
              if (fpath.substr(-11) != ".projection") continue;
              this.loadFromFiles(fpath);
            }
          } catch (e) {
            fcf.log.err("", "Can't load projection file '" + fpath + "': (" + e.toString() + ")");
            throw e;
          }
        }
      };

      this.loadFromFiles = function (a_paths) {
        var self = this;
        if (typeof a_paths == "string") a_paths = [a_paths];
        var projections = {};
        fcf.each(a_paths, function (a_key, a_path) {
          a_path = modulePath.resolve(fcf.getPath(a_path));
          var raw = fs.readFileSync(a_path, 'utf8');
          var obj = eval("(" + raw + ")");
          var proj = self.appendProjectionStruct(obj);
          projections[proj.alias] = proj;
        });
      };

      this._reloadDirectories = function () {
        try {
          for (var dirPath in this._reloadDirs) {
            this.loadFromDirectory(dirPath);
          }
        } catch (e) {
          fcf.log.err("FCF", e);
        }

        if (fcf.application.getSettings().projectionReloadingTimeout) setTimeout(function () {
          self._reloadDirectories();
        }, fcf.application.getSettings().projectionReloadingTimeout);
      };

      this.clone = function () {
        var projections = new fcf.NFSQL.Projections();
        fcf.append(projections._descs, this._descs);
        return projections;
      };

      this.appendProjections = function (a_projections) {
        fcf.append(this._descs, a_projections._descs);
      };

      this.appendProjectionStruct = function (a_objProjection) {
        a_objProjection = fcf.append({}, a_objProjection);
        a_objProjection.fields = fcf.append([], a_objProjection.fields);

        if (a_objProjection["extends"]) {
          a_objProjection = this._extends(a_objProjection);
          if (!a_objProjection) return;
        }

        a_objProjection.externalAccess = fcf.append({
          read: true,
          edit: true,
          add: true,
          delete: true
        }, a_objProjection.externalAccess);
        a_objProjection.singleTitle = a_objProjection.singleTitle ? a_objProjection.singleTitle : "";
        var translate = false;

        for (var i = 0; i < a_objProjection.fields.length; ++i) {
          var f = a_objProjection.fields[i];
          if (!("field" in f)) f.field = f.alias;
          if (!("alias" in f)) f.alias = f.field;
          if (!("title" in f)) f.title = f.alias;
          if (f.translate) translate = true;
        }

        if (translate) a_objProjection.translate = true;
        if (!('connectionGroup' in a_objProjection)) a_objProjection.connectionGroup = "default";
        this._descs[a_objProjection.alias] = this._createAdaptProjection(a_objProjection);

        this._processJoinFileds(a_objProjection.alias);

        this._continueProcessingPendingExtends();

        this._processJoinFileds();

        return this._descs[a_objProjection.alias];
      };

      this.get = function (a_alias) {
        return this._descs[a_alias];
      };

      this.getProjections = function () {
        return this._descs;
      };

      this.checkProjections = function () {
        /* throw */
        fcf.each(this._descs, function (a_key, a_projection) {
          if (fcf.empty(a_projection.alias)) throw new fcf.Exception("ERROR_UNKNOWN_FIELD_TYPE", {
            param: "alias",
            projection: a_projection.alias
          });
          if (fcf.empty(a_projection.table)) throw new fcf.Exception("ERROR_UNKNOWN_FIELD_TYPE", {
            param: "table",
            projection: a_projection.alias
          });
          if (fcf.empty(a_projection.title)) throw new fcf.Exception("ERROR_UNKNOWN_FIELD_TYPE", {
            param: "title",
            projection: a_projection.alias
          });
          if (fcf.empty(a_projection.key)) throw new fcf.Exception("ERROR_UNKNOWN_FIELD_TYPE", {
            param: "key",
            projection: a_projection.alias
          });

          if (!fcf.empty(a_projection.join)) {
            fcf.each(a_projection.join, function (a_key, a_join) {
              if (a_join.as) if (!fcf.getProjection(a_join.from)) throw new fcf.Exception("ERROR_UNKNOWN_PROJECTION_IN_JOIN", {
                joinProjection: a_join.from,
                projection: a_projection.alias
              });
              if (fcf.empty(a_join.where)) throw new fcf.Exception("ERROR_PROJECTION_UNSET_WHERE", {
                projection: a_projection.alias
              });
            });
          }

          if (fcf.empty(a_projection.fields)) throw new fcf.Exception("ERROR_UNKNOWN_FIELD_TYPE", {
            param: "fields",
            projection: a_projection.alias
          });
          fcf.each(a_projection.join, function (a_key, a_field) {
            if (fcf.empty(a_field.alias)) throw new fcf.Exception("ERROR_PROJECTION_UNSET_ALIAS", {
              projection: a_projection.alias
            });
            if (fcf.empty(a_field.type)) throw new fcf.Exception("ERROR_PROJECTION_UNSET_TYPE", {
              projection: a_projection.alias
            });
            var filter = fcf.getFilter(a_field);
            if (filter) throw new fcf.Exception("ERROR_UNKNOWN_FIELD_TYPE", {
              param: a_field.alias,
              projection: a_projection.alias
            });
            filter.checkStructure(a_projection, a_field);
          });
        });
      };

      this._processJoinFileds = function (a_projection) {
        var projections = a_projection ? [a_projection] : this._pendingJoin;
        fcf.each(projections, function (keyProjection, projectionAlias) {
          var projection = self.get(projectionAlias);
          var fullProcess = true;
          fcf.each(projection.fields, function (keyField, field) {
            if (typeof field.join !== "object") return;
            var joinKey = fcf.find(projection.join, function (a_key, a_value) {
              return a_value.as == field.join.from || a_value.from == field.join.from;
            });
            if (joinKey === undefined) throw new fcf.Exception("ERROR_PROJECTION_UNKNOWN_JOIN_FIELD", {
              projection: projection.alias,
              field: field.alias
            });
            var join = projection.join[joinKey];

            if (!self.get(join.from)) {
              self._pendingJoin[projection.alias] = projection.alias;
              fullProcess = false;
              return;
            }

            var jproj = self.get(join.from);
            var jfield = jproj.mapFields[field.join.field];
            var newField = fcf.append({}, jfield, field);
            fcf.append(field, newField);
          });
          if (fullProcess) delete self._pendingJoin[projection.alias];
        });
      };

      this._continueProcessingPendingExtends = function () {
        var numberProcessed = undefined;

        do {
          numberProcessed = 0;
          var rmkeys = [];

          for (var k in this._pendingExtends) {
            var projection = this._extends(this._pendingExtends);

            if (!projection) continue;
            rmkeys.push(k);
            this._descs[projection.alias] = this._createAdaptProjection(projection);

            this._processJoinFileds(projection.alias);

            this._processJoinFileds();

            ++numberProcessed;
          }

          for (var i = 0; i < rmkeys.length; ++i) {
            delete this._pendingExtends[rmkeys[i]];
          }
        } while (numberProcessed != 0);
      };

      this._extends = function (a_objProjection) {
        var parent = this.get(a_objProjection["extends"]);

        if (!parent) {
          this._pendingExtends[a_objProjection.alias] = a_objProjection;
          return;
        }

        var expandableProjection = fcf.append(true, {}, parent);
        delete expandableProjection.mapFields;
        fcf.append(expandableProjection, a_objProjection);
        expandableProjection.fields = fcf.append(true, [], parent.fields);
        var expandableFields = expandableProjection.fields;
        var selfFields = a_objProjection.fields;

        for (var i = 0; i < selfFields.length; ++i) {
          var key = fcf.find(expandableFields, function (k, v) {
            return v.alias == selfFields[i].alias;
          });

          if (key === undefined) {
            expandableFields.push(selfFields[i]);
          } else {
            if (!selfFields[i]["extends"]) expandableFields[key] = selfFields[i];else fcf.append(expandableFields[key], selfFields[i]);
          }
        }

        return expandableProjection;
      };

      this._createAdaptProjection = function (a_objProjection) {
        var adaptProjection = fcf.append({}, a_objProjection);
        adaptProjection.mapFields = {};

        for (var key in adaptProjection.fields) {
          adaptProjection.mapFields[adaptProjection.fields[key].alias] = adaptProjection.fields[key];
        }

        return adaptProjection;
      };

      if (fcf.application && fcf.application.getSettings() && !fcf.application.getSettings().fileСaching) setTimeout(function () {
        self._reloadDirectories();
      }, 2000);
    };

    return fcf.NFSQL.Projections;
  }
});
fcf.module({
  name: "fcf:NFSQL/NDetails/Errors.js",
  dependencies: [],
  module: function module() {
    fcf.addException("ERROR_NFSQL_EXTERNAL_ACCESS_DENIED", "External access is denied for projection '${{projection}}$'. Mode: ${{mode}}$");
    fcf.addException("ERROR_NFSQL_UNKNOWN_FUNCTION", "The request uses an unknown function '${{function}}$'");
    fcf.addException("ERROR_NFSQL_UNKNOWN_PROJECTION_IN_QUERY", "The projection ${{1}}$ specified was not found in the request");
    fcf.addException("ERROR_NFSQL_UNKNOWN_CLIENT_GROUP_IN_QUERY", "DB connection client not found for connection group ${{1}}$");
    fcf.addException("ERROR_NFSQL_UNKNOWN_PROJECTION_IN_REF", "The projection ${{refproj}}$ of the reference field ${{field}}$ is not available");
    fcf.addException("ERROR_NFSQL_UNKNOWN_FIELD_IN_REF", "The ${{reffield}}$ field does not exist for the reference field ${{field}}$");
    fcf.addException("ERROR_NFSQL_MISSING_FIELD_HANDLER", "The '${{projection}}$.${{field}}$ ' field does not have a handler for '${{handlerName}}$'");
    fcf.addException("ERROR_NFSQL_UNKNOWN_PROJECTION_IN_FIELD", "The projection ${{projection}}$ for the field ${{field}}$ is not available");
    fcf.addException("ERROR_NFSQL_UNKNOWN_FIELD_IN_QUERY", "The field ${{field}}$ is missing in the projection ${{projection}}$");
    fcf.addException("ERROR_NFSQL_UNKNOWN_FUNCTION_IN_QUERY", "The ${{function}}$ function specified in the request is not available");
    fcf.addException("ERROR_NFSQL_FIELD_SINGLE_REF_INCORECT_SUBFIELD", "An invalid subfield ${{subfield}}$ was specified for the field '${{projection}}$.${{field}}$'");
    fcf.addException("ERROR_NFSQL_FIELD_SINGLE_REF_INCORECT_MODE", "Invalid mode specified in the ${{mode}}$ for the '${{projection}}$.${{field}}$' field");
    fcf.addException("ERROR_NFSQL_FIELD_MAX_LENGTH", "The length of the field '${{projection}}$.${{field}}$' exceeds the maximum length of ${{length}}$");
    fcf.addException("ERROR_NFSQL_FIELD_MIN_LENGTH", "The length of the field '${{projection}}$.${{field}}$' is less than the minimum length ${{length}}$");
    fcf.addException("ERROR_NFSQL_NOTNULL_FIELD_NOTNULL", "The field '${{projection}}$.${{field}}$' marked as NOT NULL is not specified");
    fcf.addException("ERROR_NFSQL_NOTNULL_FIELD_NOTCREATE", "The field ' ${{projection}}$.${{field}}$' cannot be set when creating a record");
    fcf.addException("ERROR_NFSQL_INCORRECT_INTEGER_TYPE", "The value ${{value}}$ of the field '${{projection}}$.${{field}}$' does not match the int type");
    fcf.addException("ERROR_NFSQL_INCORRECT_INTEGER_MIN", "The value ${{value}}$ of the field '${{projection}}$.${{field}}$' is less than the minimum value ${{min}}$");
    fcf.addException("ERROR_NFSQL_INCORRECT_INTEGER_MAX", "The value ${{value}}$ of the field '${{projection}}$.${{field}}$' is greater than the maximum value ${{max}}$");
    fcf.addException("ERROR_NFSQL_INCORRECT_FLOAT_TYPE", "The value ${{value}}$ of the field '${{projection}}$.${{field}}$' does not match the float type");
    fcf.addException("ERROR_NFSQL_INCORRECT_FLOAT_MIN", "The value ${{value}}$ of the field '${{projection}}$.${{field}}$' is less than the minimum value ${{min}}$");
    fcf.addException("ERROR_NFSQL_INCORRECT_FLOAT_MAX", "The value ${{value}}$ of the field '${{projection}}$.${{field}}$' is greater than the maximum value ${{max}}$");
    fcf.addException("ERROR_NFSQL_INCORRECT_BOOLEAN_TYPE", "The value ${{value}}$ of the field '${{projection}}$.${{field}}$' does not match the boolean type");
    fcf.addException("ERROR_NFSQL_FIELD_EXTERNREF_INCORRECT_PROJECTION", "The '${{refprojection}}$' projection of an external link is not available for the '${{projection}}$.${{field}}$' field");
    fcf.addException("ERROR_NFSQL_FIELD_EXTERNREF_INCORRECT_SELFFIELD", "The selfField parameter for the field '${{projection}}$.${{field}}$ ' refers to the invalid field '${{refprojection}}$.${{reffield}}$'");
    fcf.addException("ERROR_NFSQL_FIELD_EXTERNREF_INCORRECT_REFFIELD", "The refField parameter for the field '${{projection}}$.${{field}}$ ' refers to the invalid field '${{refprojection}}$.${{reffield}}$'");
    fcf.addException("ERROR_NFSQL_FIELD_EXTERNREF_INCORRECT_SELFFIELD_NOTREF", "The selfField parameter for the field '${{projection}}$.${{field}}$' refers to the field '${{refprojection}}$.${{reffield}}$' which is not a singleref type");
    fcf.addException("ERROR_NFSQL_FIELD_EXTERNREF_INCORRECT_REFFIELD_NOTREF", "The refField parameter for the field '${{projection}}$.${{field}}$' refers to the field '${{refprojection}}$.${{reffield}}$' which is not a single red type");
    fcf.addException("ERROR_NFSQL_FIELD_EXTERNREF_INCORRECT_SUBFIELD", "The field '${{projection}}$.${{field}}$' does not support the subfield '${{subfield}}$'");
    fcf.addException("ERROR_NFSQL_INCORRECT_QUERY_OBJECT", "Invalid object request format");
    fcf.addException("ERROR_NFSQL_INCORRECT_TYPE_QUERY", "Invalid object request type ${{type}}$");
  }
});
fcf.module({
  name: "fcf:NFSQL/NDetails/SingleBuilder.js",
  dependencies: ["fcf:NFSQL/NDetails/Errors.js"],
  module: function module(NFSQLErrors) {
    var NDetails = fcf.prepareObject(fcf, "NFSQL.NDetails");

    NDetails.SingleBuilder = function () {
      /**
      * @fn struct build(a_options)
      * @brief Выполняет сборку строкового FSQL запроса на базе объектного
      * @param struct a_query Объектный запрос FSQL
      **/
      this.build = function (a_query, a_startArgCounter) {
        if (typeof a_query !== "object") throw new fcf.Exception("ERROR_NFSQL_INCORRECT_QUERY_OBJECT", []);
        a_startArgCounter = a_startArgCounter ? a_startArgCounter : 0;

        if (a_query.type === "delete") {
          return this._buildDelete(a_query, a_startArgCounter);
        } else if (a_query.type === "update") {
          return this._buildUpdate(a_query, a_startArgCounter);
        } else if (a_query.type === "insert") {
          return this._buildInsert(a_query, a_startArgCounter);
        } else if (a_query.type === "select") {
          return this._buildSelect(a_query, a_startArgCounter);
        } else {
          throw new fcf.Exception("ERROR_NFSQL_INCORRECT_TYPE_QUERY", {
            type: a_query.type
          });
        }
      };

      this._buildSelect = function (a_query, a_startArgCounter) {
        var result = {
          query: "SELECT",
          args: [],
          details: {
            count: a_startArgCounter
          }
        };
        var isFirst = true;

        for (var i = 0; i < a_query.fields.length; ++i) {
          result.query += isFirst ? " " : ", ";

          this._buildArgResult(result, a_query.fields[i]);

          isFirst = false;
        }

        result.query += " FROM ";

        this._buildFrom(result, a_query.from);

        if (Array.isArray(a_query.join)) {
          for (var i = 0; i < a_query.join.length; ++i) {
            var join = a_query.join[i];
            result.query += typeof join.join == "string" && join.join.toLowerCase() == "left" ? " LEFT JOIN " : typeof join.join == "string" && join.join.toLowerCase() == "right" ? " RIGHT JOIN " : " JOIN ";

            if (typeof join.query == "object") {
              var subquery = this.build(join.query, result.details.count);
              result.query += "(";
              result.query += subquery.query;
              result.query += ")";
              fcf.append(result.args, subquery.args);
              result.details.count += subquery.args.length;
            } else {
              this._buildSafeElement(result, join.from);
            }

            if (!fcf.empty(join.as)) {
              result.query += " AS ";

              this._buildSafeElement(result, join.as);
            }

            result.query += " ON";

            this._buildWhere(result, join.on, true);
          }
        }

        this._buildWhere(result, a_query.where);

        if (!fcf.empty(a_query.group)) {
          result.query += " GROUP BY ";
          var isFirst = true;

          for (var i = 0; i < a_query.group.length; ++i) {
            result.query += isFirst ? "" : ", ";
            isFirst = false;

            this._buildSafeElement(result, a_query.group[i]);
          }
        }

        if (!fcf.empty(a_query.order)) {
          result.query += " ORDER BY";
          var isFirst = true;

          for (var i = 0; i < a_query.order.length; ++i) {
            result.query += isFirst ? " " : ", ";
            isFirst = false;

            this._buildField(result, a_query.order[i]);

            result.query += a_query.order[i].order.toLowerCase() == "desc" ? " DESC" : " ASC";
          }
        }

        if (!fcf.empty(a_query.limit)) {
          result.query += " LIMIT ";

          this._buildValue(result, a_query.limit);
        }

        if (!fcf.empty(a_query.offset)) {
          result.query += " OFFSET ";

          this._buildValue(result, a_query.offset);
        }

        if (!fcf.empty(a_query.language)) {
          result.query += " LANGUAGE " + a_query.language;
          if (a_query.defaultLanguage) result.query += " DEFAULT ";
        }

        delete result.details;
        return result;
      };

      this._buildInsert = function (a_query, a_startArgCounter) {
        var result = {
          query: "INSERT INTO ",
          args: [],
          details: {
            count: a_startArgCounter
          }
        };

        this._buildFrom(result, a_query.from);

        result.query += " (";
        var isFirst = true;

        for (var i = 0; i < a_query.values.length; ++i) {
          if (!isFirst) result.query += ", ";else result.query += " ";

          this._buildSafeElement(result, a_query.values[i].field);

          isFirst = false;
        }

        result.query += " ) VALUES (";
        var isFirst = true;

        for (var i = 0; i < a_query.values.length; ++i) {
          if (!isFirst) result.query += ", ";else result.query += " ";

          this._buildArg(result, a_query.values[i], true);

          isFirst = false;
        }

        result.query += " )";

        if (!fcf.empty(a_query.language)) {
          result.query += " LANGUAGE " + a_query.language;
          if (a_query.defaultLanguage) result.query += " DEFAULT ";
        }

        delete result.details;
        return result;
      };

      this._buildUpdate = function (a_query, a_startArgCounter) {
        var result = {
          query: "UPDATE ",
          args: [],
          details: {
            count: a_startArgCounter
          }
        };

        this._buildFrom(result, a_query.from);

        if (Array.isArray(a_query.join)) {
          for (var i = 0; i < a_query.join.length; ++i) {
            var join = a_query.join[i];
            result.query += typeof join.join == "string" && join.join.toLowerCase() == "left" ? " LEFT JOIN " : typeof join.join == "string" && join.join.toLowerCase() == "right" ? " RIGHT JOIN " : " JOIN ";

            this._buildSafeElement(result, join.from);

            if (!fcf.empty(join.as)) {
              result.query += " AS ";

              this._buildSafeElement(result, join.as);
            }

            result.query += " ON";

            this._buildWhere(result, join.on, true);
          }
        }

        result.query += " SET";
        var isFirst = true;

        for (var i = 0; i < a_query.values.length; ++i) {
          if (!isFirst) result.query += ", ";else result.query += " ";

          this._buildSafeElement(result, a_query.values[i].field);

          result.query += " = ";

          this._buildArg(result, a_query.values[i], true);

          isFirst = false;
        }

        this._buildWhere(result, a_query.where);

        if (!fcf.empty(a_query.language)) {
          result.query += " LANGUAGE " + a_query.language;
          if (a_query.defaultLanguage) result.query += " DEFAULT ";
        }

        delete result.details;
        return result;
      };

      this._buildDelete = function (a_query, a_startArgCounter) {
        var result = {
          query: "DELETE FROM ",
          args: [],
          details: {
            count: a_startArgCounter
          }
        };

        this._buildFrom(result, a_query.from);

        this._buildWhere(result, a_query.where);

        if (!fcf.empty(a_query.language)) {
          result.query += " LANGUAGE " + a_query.language;
        }

        delete result.details;
        return result;
      };

      this._buildWhere = function (a_result, a_where, a_isNotRoot) {
        if (fcf.empty(a_where)) return;
        var startLength = a_result.query.length;
        var isEmpty = true;
        if (!a_isNotRoot) a_result.query += " WHERE";

        for (var i = 0; i < a_where.length; ++i) {
          if (i !== 0) {
            var logic = a_where[i].logic ? a_where[i].logic.toUpperCase() : "AND";
            a_result.query += " " + logic;
          }

          if (a_where[i].not) {
            a_result.query += " NOT";
          }

          var type = a_where[i].type;

          if (type == "true") {
            a_result.query += " TRUE ";
            isEmpty = false;
          } else if (type == "false") {
            a_result.query += " FALSE ";
            isEmpty = false;
          } else if (type != "block") {
            a_result.query += " ";

            this._buildArg(a_result, a_where[i].args[0]);

            a_result.query += " ";
            a_result.query += type;
            a_result.query += " ";

            this._buildArg(a_result, a_where[i].args[1]);

            isEmpty = false;
          } else {
            if (!fcf.empty(a_where[i].args)) {
              a_result.query += " (";

              this._buildWhere(a_result, a_where[i].args, true);

              a_result.query += " )";
              isEmpty = false;
            }
          }
        }

        if (isEmpty) a_result.query = a_result.query.substr(0, startLength);
      };

      this._buildSafeElement = function (a_result, a_elem) {
        a_elem = fcf.replaceAll(a_elem, "\"", "\\\"");
        a_result.query += "\"" + a_elem + "\"";
      };

      this._buildFrom = function (a_result, a_from) {
        this._buildSafeElement(a_result, a_from);
      };

      this._buildArgResult = function (a_result, a_fieldInfo) {
        this._buildArg(a_result, a_fieldInfo);

        if (!fcf.empty(a_fieldInfo.as)) {
          a_result.query += " AS ";

          this._buildSafeElement(a_result, a_fieldInfo.as);
        }
      };

      this._buildField = function (a_result, a_fieldInfo) {
        if (a_fieldInfo.from) {
          this._buildSafeElement(a_result, a_fieldInfo.from);

          a_result.query += ".";
        }

        if (a_fieldInfo.field == "*") a_result.query += "*";else this._buildSafeElement(a_result, a_fieldInfo.field);

        if (a_fieldInfo.mode) {
          a_result.query += ":";
          a_result.query += a_fieldInfo.mode;
        }

        fcf.each(a_fieldInfo.path, function (a_key, a_value) {
          a_result.query += "->\"";
          a_result.query += fcf.escapeQuotes(a_value);
          a_result.query += "\"";
        });
      };

      this._buildValue = function (a_result, a_value) {
        a_result.args.push(a_value);
        a_result.query += "${" + ++a_result.details.count + "}";
      };

      this._buildResult = function (a_result, a_arg) {
        a_result.query += "$[" + a_arg.result + "][" + a_arg.record + "][\"" + a_arg.item + "\"]";
      };

      this._buildArg = function (a_result, a_arg, a_isNotField) {
        if (!a_isNotField && "field" in a_arg) {
          this._buildField(a_result, a_arg);
        } else if ("function" in a_arg) {
          this._buildSafeElement(a_result, a_arg["function"]);

          a_result.query += "(";

          if (Array.isArray(a_arg.args)) {
            for (var i = 0; i < a_arg.args.length; ++i) {
              this._buildArg(a_result, a_arg.args[i], a_isNotField);
            }
          }

          a_result.query += ")";
        } else if ("value" in a_arg) {
          this._buildValue(a_result, a_arg.value);
        } else if ("result" in a_arg) {
          this._buildResult(a_result, a_arg);
        }
      };
    };

    return NDetails.SingleBuilder;
  }
});
fcf.module({
  name: "fcf:NFSQL/Builder.js",
  dependencies: ["fcf:NFSQL/NDetails/SingleBuilder.js"],
  module: function module(SingleBuilder) {
    var NFSQL = fcf.prepareObject(fcf, "NFSQL");

    NFSQL.Builder = function () {
      this._builder = new SingleBuilder();

      this.build = function (a_queryObjects) {
        var result = {
          query: "",
          args: []
        };
        a_queryObjects = Array.isArray(a_queryObjects) ? a_queryObjects : [a_queryObjects];

        for (var i = 0; i < a_queryObjects.length; ++i) {
          var resItem = this._builder.build(a_queryObjects[i], result.args.length);

          if (i != 0) result.query += "; ";
          result.query += resItem.query;
          fcf.append(result.args, resItem.args);
        }

        return result;
      };
    };

    return NFSQL.Builder;
  }
});
fcf.module({
  name: "fcf:NFSQL/NDetails/ClientStorage.js",
  dependencies: ["fcf:NFSQL/Builder.js"],
  module: function module(Builder) {
    var NDetails = fcf.prepareObject(fcf, "NFSQL.NDetails");

    NDetails.ClientStorage = function (a_options) {
      this._builder = new Builder();

      this.query = function (a_options, a_cb) {
        var query = a_options.query;
        var args = a_options.args ? a_options.args : [];

        try {
          if (typeof query === "object") {
            var txtQuery = this._builder.build(query);

            query = txtQuery.query;
            args = txtQuery.args;
          }
        } catch (e) {
          a_cb(e);
          return;
        }

        var url = fcf.application.getSettings().FSQLPath ? fcf.application.getSettings().FSQLPath : "@url:fcfFSQL";
        url = fcf.buildUrl(url, {
          query: query
        });
        fcf.loadObject({
          path: url,
          post: {
            args: args
          },
          onResult: function onResult(a_error, a_response) {
            a_cb(a_error, a_response);
          }
        });
      };

      this.destroy = function () {};
    };

    return NDetails.ClientStorage;
  }
});
fcf.module({
  name: "fcf:NFSQL/Storage.js",
  dependencies: [fcf.isServer() ? "fcf:NFSQL/NDetails/ServerStorage.js" : "fcf:NFSQL/NDetails/ClientStorage.js"],
  module: function module(ImplStorage) {
    var NFSQL = fcf.prepareObject(fcf, "NFSQL");

    NFSQL.Storage = function (a_options) {
      var self = this;
      this._storage = new ImplStorage(a_options);
      this._projections = a_options.projections;

      this.query = function (a_options, a_cb) {
        var args = arguments;

        if (typeof a_options == "object" && a_options.type || Array.isArray(a_options)) {
          a_options = {
            query: a_options
          };
        } else if (typeof args[0] == "string") {
          a_options = {
            query: a_options
          };

          if (Array.isArray(args[1])) {
            a_options.args = args[1];
            a_cb = args[2];
          }
        }

        return fcf.actions().exec(function (a_act) {
          self._storage.query(a_options, function (a_error, a_data) {
            if (a_cb) a_cb(a_error, a_data);

            if (a_error) {
              if (fcf.find(a_options.hideErrors, a_error.code) !== undefined) {
                a_act.complete([]);
              } else {
                a_act.error(a_error);
              }
            } else {
              a_act.complete(a_data);
            }
          });
        });
      };

      this.rawQuery = function (a_query, a_args, a_cb) {
        if (typeof a_args === "function") {
          a_cb = a_args;
          a_args = [];
        }

        return fcf.actions().exec(function (a_act) {
          self._storage.rawQuery(a_query, a_args, function (a_error, a_data) {
            if (a_cb) a_cb(a_error, a_data);
            if (a_error) a_act.error(a_error);else a_act.complete(a_data);
          });
        });
      };

      this.destroy = function () {
        this._storage.destroy();
      };

      this.getStorage = function () {
        return this._storage;
      };

      this.getProjections = function () {
        return this._projections;
      };
    };

    return NFSQL.Storage;
  }
});
fcf.module({
  name: "fcf:NEvent/Error.js",
  dependencies: [],
  module: function module() {
    var NEvent = fcf.prepareObject(fcf, "NEvent");

    NEvent.Error = function (a_args, a_subEvent) {
      fcf.Event.call(this, "error", a_args, a_subEvent);
      this.directionalСall = false; //this.owner
      //this.error
    };

    return NEvent.Error;
  }
});
fcf.module({
  name: "fcf:NServer/Configuration.js",
  dependencies: [],
  module: function module() {
    var NServer = fcf.prepareObject(fcf, "NServer");

    NServer.Configuration = function () {
      var self = this;
      this._configuration = {
        aliases: {},
        views: {},
        html: {
          include: {}
        },
        inheritanceModes: {},
        filters: {},
        functions: {}
      };

      this.getConfiguration = function () {
        return this._configuration;
      };

      this.get = function (a_part) {
        return this._configuration[a_part];
      };

      this.appendPackageInfo = function (a_name, a_data, a_isTheme) {
        if (typeof a_data.aliases == "object") {
          fcf.append(this._configuration.aliases, a_data.aliases);
        }

        if (typeof a_data.views == "object") {
          for (var mask in a_data.views) {
            if (!(mask in this._configuration.views)) this._configuration.views[mask] = {};
            fcf.append(this._configuration.views[mask], a_data.views[mask]);
          }
        }

        if (!a_isTheme) {
          if (typeof a_data.html == "object" && typeof a_data.html.include == "object") {
            fcf.append(this._configuration.html.include, a_data.html.include);
          }
        }

        if (typeof a_data.inheritanceModes == "object") {
          fcf.append(this._configuration.inheritanceModes, a_data.inheritanceModes);
        }

        if (typeof a_data.filters == "object") {
          fcf.append(this._configuration.filters, a_data.filters);
        }

        if (typeof a_data.functions == "object") {
          fcf.append(this._configuration.fsqlFunctions, a_data.functions);
        }

        if (typeof a_data.cacheDirectory == "string") this._configuration.cacheDirectory = a_data.cacheDirectory;
        if (typeof a_data.directorySystemProjections == "string") this._configuration.directorySystemProjections = a_data.directorySystemProjections;
        if (typeof a_data.fileDirectory == "string") this._configuration.fileDirectory = a_data.fileDirectory;
        if (a_data.maxSizeReceived) this._configuration.maxSizeReceived = a_data.maxSizeReceived;
        if (a_data.maxUrlCountParametersReceived) this._configuration.maxUrlCountParametersReceived = a_data.maxUrlCountParametersReceived;
        if (typeof a_data.imageDirectory == "string") this._configuration.imageDirectory = a_data.imageDirectory;

        if (typeof a_data.packages == "object") {
          fcf.each(a_data.packages, function (a_key, a_value) {
            if (!self._configuration.packages) self._configuration.packages = {};
            if (!self._configuration.packages[a_key]) self._configuration.packages[a_key] = {};
            fcf.append(self._configuration.packages[a_key], a_value);
          });
        }
      };
    };

    return NServer.Configuration;
  }
});
fcf.module({
  name: "fcf:NClient/LocalData.js",
  dependencies: [],
  debug: true,
  module: function module() {
    var NClient = fcf.prepareObject(fcf, "NClient");

    NClient.LocalData = function () {
      var self = this;
      this._data = {};
      this._dataKeys = {};
      this._originData = {};
      this._sources = {};
      this._originSources = {};

      this.setOriginData = function (a_origin) {
        fcf.append(this._originData, a_origin);
      };

      this.setSourcesData = function (a_origin) {
        for (var id in a_origin) {
          var object = {};

          for (var key in a_origin[id]) {
            object[fcf.normalizeObjectAddress(key)] = a_origin[id][key];
          }

          this._sources[id] = object;
          if (!(id in this._originSources)) this._originSources[id] = fcf.append(true, {}, a_origin[id]);
        }
      };

      this.setOriginObject = function (a_objectId, a_data) {
        this._originData[a_objectId] = a_data;
      };

      this.setObject = function (a_objectId, a_data) {
        this._data[a_objectId] = a_data;
      };

      this.setSourceObject = function (a_objectId, a_data) {
        this._sources[a_objectId] = a_data;
        if (!(a_objectId in this._originSources)) this._originSources[a_objectId] = fcf.append(true, {}, a_data);
      };

      this.setSourceItem = function (a_objectId, a_item, a_value) {
        if (!this._sources[a_objectId]) this._sources[a_objectId] = {};
        var na = fcf.normalizeObjectAddress(a_item);
        this._sources[a_objectId][na] = a_value;
        if (!(a_objectId in this._originSources)) this._originSources[a_objectId] = fcf.append(true, {}, this._sources[a_objectId]);
      };

      this.setOriginItem = function (a_objectId, a_item, a_value) {
        if (!this._originData[a_objectId]) this._originData[a_objectId] = {};
        var ptr = fcf.resolveEx(this._originData[a_objectId], a_item, true);
        ptr.object[ptr.key] = a_value;
      };

      this.setItem = function (a_objectId, a_item, a_value) {
        var parts = fcf.parseObjectAddress(a_item);
        var argName = "";
        var argSuffix = "";
        var source = undefined;

        for (var i = 0; i < parts.length; ++i) {
          argName = "";
          argSuffix = "";
          var size = parts.length - i;

          for (var j = 0; j < parts.length; ++j) {
            if (j < size) argName += '["' + parts[j] + '"]';else argSuffix += '["' + parts[j] + '"]';
          }

          var source = fcf.application.getLocalData().getSourceItem(a_objectId, argName);
          if (source !== undefined) break;
        }

        if (fcf.isArg(source) && source.type === "reference") {
          var id = source.id;

          if (id.indexOf("@{{") !== -1 || id.indexOf("${{") !== -1) {
            var args = fcf.application.getLocalData().getObject(a_objectId);
            id = fcf.tokenize(id, {
              args: args
            });
          }

          var path = source.arg + argSuffix;

          if (path.indexOf("@{{") !== -1 || path.indexOf("${{") !== -1) {
            var args = fcf.application.getLocalData().getObject(a_objectId);
            path = fcf.tokenize(path, {
              args: args
            });
          }

          return this.setItem(id, path, a_value);
        }

        if (!this._data[a_objectId]) this._data[a_objectId] = {};
        if (!this._dataKeys[a_objectId]) this._dataKeys[a_objectId] = {};

        if (argSuffix && fcf.resolve(this._data[a_objectId], argName) === undefined) {
          if (!this._originData[a_objectId]) this._originData[a_objectId] = {};
          var orgPtr = fcf.resolveEx(this._originData[a_objectId], argName, true);
          var modPtr = fcf.resolveEx(this._data[a_objectId], argName, true);
          modPtr.object[modPtr.key] = fcf.clone(orgPtr.object[orgPtr.key]);
        }

        itemPtr = fcf.resolveEx(this._data[a_objectId], a_item, true);
        itemPtr.object[itemPtr.key] = a_value;
        var normArgName = fcf.normalizeObjectAddress(argName);
        this._dataKeys[a_objectId][normArgName] = normArgName;
      };

      this.removeObject = function (a_objectId) {
        delete this._originData[a_objectId];
        delete this._data[a_objectId];
        delete this._sources[a_objectId];
        delete this._originSources[a_objectId];
      };

      this.getObject = function (a_objectId) {
        var dataObject = {};
        fcf.append(dataObject, this._originData[a_objectId]);
        fcf.each(this._dataKeys[a_objectId], function (a_key) {
          var dstPtr = fcf.resolveEx(dataObject, a_key, true);
          var dataPtr = fcf.resolveEx(self._data[a_objectId], a_key);
          if (dataPtr.object && dataPtr.key in dataPtr.object) dstPtr.object[dataPtr.key] = dataPtr.object[dataPtr.key];
        });
        return dataObject;
      };

      this.setModifyKeys = function (a_objectId, a_argKey) {
        a_argKey = fcf.normalizeObjectAddress(a_argKey);
        if (!this._dataKeys[a_objectId]) this._dataKeys[a_objectId] = {};
        this._dataKeys[a_objectId][a_argKey] = a_argKey;
      };

      this.getModifyKeys = function (a_objectId) {
        return this._dataKeys[a_objectId];
      };

      this.clearModifyKeys = function (a_objectId) {
        delete this._dataKeys[a_objectId];
      };

      this.getOriginObject = function (a_objectId) {
        return this._originData[a_objectId];
      };

      this.getSourceObject = function (a_objectId) {
        return this._sources[a_objectId];
      };

      this.getOriginSourceObject = function (a_objectId) {
        return fcf.append(true, {}, this._originSources[a_objectId]);
      };

      this.resetSources = function () {
        this._sources = fcf.append(true, {}, this._originSources);
      };

      this.cleanItem = function (a_objectId, a_item) {
        if (this._data[a_objectId]) {
          a_item = fcf.normalizeObjectAddress(a_item);
          var itemPtr = fcf.resolveEx(this._data[a_objectId], a_item);
          if (itemPtr.object && itemPtr.object[itemPtr.key] !== undefined) delete itemPtr.object[itemPtr.key];
          if (this._dataKeys[a_objectId]) delete this._dataKeys[a_objectId][a_item];
        }
      };

      this.getItem = function (a_objectId, a_item) {
        var parts = fcf.parseObjectAddress(a_item);
        var argName = "";
        var argSuffix = "";
        var source = undefined;

        for (var i = 0; i < parts.length; ++i) {
          argName = "";
          argSuffix = "";
          var size = parts.length - i;

          for (var j = 0; j < parts.length; ++j) {
            if (j < size) argName += '["' + parts[j] + '"]';else argSuffix += '["' + parts[j] + '"]';
          }

          var source = fcf.application.getLocalData().getSourceItem(a_objectId, argName);
          if (source !== undefined) break;
        }

        if (fcf.isArg(source) && source.type === "reference") {
          var id = source.id;

          if (id.indexOf("@{{") !== -1 || id.indexOf("${{") !== -1) {
            var args = fcf.application.getLocalData().getObject(a_objectId);
            id = fcf.tokenize(id, {
              args: args
            });
          }

          var path = source.arg + argSuffix;

          if (path.indexOf("@{{") !== -1 || path.indexOf("${{") !== -1) {
            var args = fcf.application.getLocalData().getObject(a_objectId);
            path = fcf.tokenize(path, {
              args: args
            });
          }

          return this.getItem(id, path);
        }

        if (this._data[a_objectId]) {
          var originData = undefined;

          if (this._originData[a_objectId]) {
            var itemPtr = fcf.resolveEx(this._originData[a_objectId], a_item);
            if (itemPtr.object && itemPtr.object[itemPtr.key] !== undefined) originData = itemPtr.object[itemPtr.key];
          }

          var itemPtr = fcf.resolveEx(this._data[a_objectId], a_item);

          if (itemPtr.object && itemPtr.object[itemPtr.key] !== undefined) {
            var val = itemPtr.object[itemPtr.key];

            if (Array.isArray(val)) {
              return val;
            } else if (typeof val == "object") {
              return val;
            } else {
              return val;
            }
          }
        }

        if (this._originData[a_objectId]) {
          var itemPtr = fcf.resolveEx(this._originData[a_objectId], a_item);
          if (itemPtr.object && itemPtr.object[itemPtr.key] !== undefined) return fcf.clone(itemPtr.object[itemPtr.key]);
        }
      };

      this.getSourceItem = function (a_objectId, a_item, a_usingDepth) {
        if (!(a_objectId in this._sources)) return;

        if (a_usingDepth) {
          var parts = fcf.parseObjectAddress(a_item);

          for (var i = 0; i < parts.length; ++i) {
            var name = "";
            var size = parts.length - i;

            for (var j = 0; j < size; ++j) {
              name += '["' + parts[j] + '"]';
            }

            if (this._sources[a_objectId][name]) return this._sources[a_objectId][name];
            if (this._originSources[a_objectId] && this._originSources[a_objectId][name]) return this._originSources[a_objectId][name];
          }
        } else {
          a_item = fcf.normalizeObjectAddress(a_item);
          if (this._sources[a_objectId][a_item]) return this._sources[a_objectId][a_item];
          if (this._originSources[a_objectId] && this._originSources[a_objectId][name]) return this._originSources[a_objectId][name];
        }
      };
    };

    return NClient.LocalData;
  }
});
fcf.module({
  name: "fcf:NClient/Router.js",
  dependencies: [],
  debug: true,
  module: function module() {
    var NClient = fcf.prepareObject(fcf, "NClient");

    NClient.Router = function () {
      this._routeInfo = new fcf.RouteInfo({
        url: window.location.href
      });

      this.setRoute = function (a_route) {
        this._routeInfo.setRoute(a_route);
      };

      this.getRouteInfo = function () {
        return this._routeInfo;
      };

      this.update = function () {
        this._routeInfo.update({
          url: window.location.href
        });
      };

      this.setArg = function (a_argName, a_value) {
        this._routeInfo.args[a_argName] = a_value;

        var url = this._routeInfo.buildUrl();

        window.history.pushState(undefined, undefined, url);
      };
    };

    return NClient.Router;
  }
});
fcf.module({
  name: "fcf:NClient/Application.js",
  dependencies: ["fcf:NTheme/Themes.js", "fcf:NTheme/Theme.js", "fcf:NRender/Render.js", "fcf:NFSQL/Projections.js", "fcf:NFSQL/Storage.js", "fcf:NEvent/Error.js", "fcf:NServer/Configuration.js", "fcf:NClient/LocalData.js", "fcf:NClient/Router.js"],
  debug: true,
  module: function module(Themes, Theme, Render, Projections, Storage, Error, Configuration, LocalData, Router) {
    var NClient = fcf.prepareObject(fcf, "NClient");
    window.addEventListener('popstate', function (event) {
      if (event.state !== null) fcf.application.update();
    });

    NClient.Application = function () {
      var self = this;
      this._configuration = new Configuration();
      this._themes = new Themes({}, this._configuration);
      this._localData = new LocalData();
      this._router = new Router();
      this._lastURL = window.location.href;
      this._delayedUpdate = false;
      this._projections = new Projections();

      if (fcf.NDetails._projections) {
        for (var key in fcf.NDetails._projections) {
          this._projections.appendProjectionStruct(fcf.NDetails._projections[key]);
        }
      }

      this._settings = {
        route: window.location.href,
        fileСaching: true,
        clientRenderingMode: "client",
        defaultTheme: "defaultTheme",
        renderStorage: {},
        renderRestore: {}
      };
      this._eventChannel = new fcf.EventChannel({
        owner: this
      });
      this._storage = new Storage({
        projections: this._projections,
        eventChannel: this._eventChannel
      });
      this._render = new Render({
        application: this,
        storage: this._storage,
        fileСaching: this._settings.fileСaching,
        routeInfo: this._router.getRouteInfo()
      });

      this.render = function (a_options) {
        return fcf.actions().exec(function (a_act) {
          function clCompleteRender(a_error, a_template) {
            if (a_error) {
              fcf.log.err("FCF", a_error.message, a_error);
              if (a_options.onResult) a_options.onResult(a_error, a_template);
              a_act.error(a_error);
              return;
            }

            if (!a_options.update) {
              if (a_template.state && a_template.state.args) {
                for (var id in a_template.state.args) {
                  fcf.application.getLocalData().setOriginObject(id, a_template.state.args[id]);
                  fcf.application.getLocalData().setObject(id, {});
                  var wrp = fcf.getWrapper(id);

                  if (wrp) {
                    var rwrp = new wrp.constructor(wrp.getInitializeOptions(), true);

                    for (var k in rwrp) {
                      if (k == "_id") continue;
                      wrp[k] = rwrp[k];
                    }
                  }
                }
              }
            }

            if (a_template.state && a_template.state.sources) {
              for (var id in a_template.state.sources) {
                fcf.application.getLocalData().setSourceObject(id, a_template.state.sources[id]);
              }
            }

            function clCreate() {
              if (a_options.owner !== false) {
                a_options.owner = typeof a_options.owner == "string" ? fcf.select(a_options.owner)[0] : a_options.owner === undefined ? document.body : a_options.owner;

                if (!a_template.args.fcfWrapper) {
                  var div = document.createElement("div");
                  div.innerHTML = a_template.content;
                  a_template.domElements = [];

                  for (var i = 0; i < div.children.length; ++i) {
                    var el = div.children[i];
                    a_template.domElements.push(el);
                    if (a_options.owner) a_options.owner.appendChild(el);
                  }
                } else {
                  var div = document.createElement("div");
                  div.innerHTML = a_template.content;
                  a_template.domElement = div.firstChild;
                  a_template.domElements = [a_template.domElement];
                  if (a_options.owner) a_options.owner.appendChild(a_template.domElement);
                }
              }

              var enableWrapper = a_options.wrapper !== undefined ? a_options.wrapper : true;

              if (enableWrapper && a_template.args.fcfWrapper) {
                fcf.liven(a_template.domElement, function () {
                  a_template.wrapper = fcf.NDetails._wrappers[a_template.id];
                  if (a_options.onResult) a_options.onResult(a_error, a_template);
                  a_act.complete(a_template);
                });
              } else {
                if (a_options.onResult) a_options.onResult(a_error, a_template);
                a_act.complete(a_template);
              }
            }

            if (Array.isArray(a_template.args.fcfInclude)) fcf.include(a_template.args.fcfInclude, clCreate);else clCreate();
          }

          var renderMode = !a_options.renderMode ? fcf.application.getSettings().clientRenderingMode : a_options.renderMode == "server" ? "server" : "client";

          if (renderMode == "server") {
            fcf.loadObject({
              path: "@url:fcfRender",
              post: {
                template: a_options.template,
                args: a_options.args,
                url: window.location.href,
                externalArgs: a_options.externalArgs
              },
              onResult: function onResult(a_error, a_response) {
                clCompleteRender(a_error, a_response);
              }
            });
          } else {
            self.getRender().render({
              template: a_options.template,
              args: a_options.args,
              theme: a_options.theme,
              update: a_options.update,
              content: fcf.getContext(),
              externalArgs: a_options.externalArgs,
              onResult: function onResult(a_error, a_template) {
                if (a_error && a_error.name == "ERROR_RENDER_SERVER_ONLY_TEMPLATE") {
                  fcf.loadObject({
                    path: "@url:fcfRender",
                    post: {
                      template: a_options.template,
                      args: a_options.args,
                      url: window.location.href
                    },
                    onResult: function onResult(a_error, a_response) {
                      clCompleteRender(a_error, a_response);
                    }
                  });
                  return;
                }

                clCompleteRender(a_error, a_template);
              }
            });
          }
        })["catch"](function (a_error) {
          fcf.application.getEventChannel().send("error", {
            error: a_error
          });
        });
      };

      this.getSettings = function () {
        this._settings.defaultTheme = this._themes.getDefaultThemeName();
        return this._settings;
      };

      this.setSettings = function (a_options) {
        if (typeof a_options == "string") {
          a_options = fcf.lz.decompressFromBase64(a_options);
          a_options = eval("(" + a_options + ")");
        }

        if (a_options.defaultTheme) {
          this._themes.setDefaultThemeName(a_options.defaultTheme);

          this._settings.defaultTheme = a_options.defaultTheme;
        }

        if (a_options.renderStorage) {
          this._localData.setOriginData(a_options.renderStorage);
        }

        if (a_options.renderRestore) {
          this._localData.setSourcesData(a_options.renderRestore);
        }

        if (a_options.clientRenderingMode) {
          this._settings.clientRenderingMode = a_options.clientRenderingMode == "server" ? "server" : "client";
        }

        if (a_options.fileСaching !== undefined) {
          this._settings.fileСaching = !!a_options.fileСaching;

          this._render.setFileСaching(!!a_options.fileСaching);
        }

        if (a_options.route !== undefined) {
          this._router.setRoute(a_options.route);
        }

        if (a_options.context !== undefined) {
          fcf.setContext(new fcf.Context(a_options.context));
        }

        return this;
      };

      this.selectSystemVariables = function (a_variables, a_options, a_cb) {
        if (typeof a_options === "function") {
          a_cb = a_options;
          a_options = {};
        }

        if (!a_options) a_options = {};
        var result = {};
        a_variables = Array.isArray(a_variables) ? a_variables : [a_variables];
        var query = {
          type: "select",
          from: "fcf_variables",
          fields: [{
            field: "value"
          }, {
            field: "name"
          }, {
            field: "package"
          }],
          where: []
        };

        for (var i = 0; i < a_variables.length; ++i) {
          result[a_variables[i]] = null;
          var pos = a_variables[i].indexOf(":");
          var pack = pos != -1 ? a_variables[i].substr(0, pos) : "";
          var name = pos != -1 ? a_variables[i].substr(pos + 1) : a_variables[i];
          query.where.push({
            logic: "or",
            type: "block",
            args: [{
              logic: "and",
              type: "=",
              args: [{
                field: "package"
              }, {
                value: pack
              }]
            }, {
              logic: "and",
              type: "=",
              args: [{
                field: "name"
              }, {
                value: name
              }]
            }]
          });
        }

        var queryOptions = fcf.append({}, a_options, {
          query: query
        });
        return self.getStorage().query(queryOptions).then(function (a_data) {
          for (var i = 0; i < a_data[0].length; ++i) {
            result[a_data[0][i]["package"] + ":" + a_data[0][i].name] = fcf.strToObject(a_data[0][i].value);
          }

          if (a_cb) a_cb(undefined, result);
          return result;
        })["catch"](function (a_error) {
          a_cb(a_error);
        });
      };

      this.selectSystemVariable = function (a_variable, a_options, a_cb) {
        if (typeof a_options === "function") {
          a_cb = a_options;
          a_options = {};
        }

        if (!a_options) a_options = {};
        var result = undefined;
        var pos = a_variable.indexOf(":");
        var pack = pos != -1 ? a_variable.substr(0, pos) : "";
        var name = pos != -1 ? a_variable.substr(pos + 1) : a_variable;
        var query = {
          type: "select",
          from: "fcf_variables",
          fields: [{
            field: "value"
          }, {
            field: "name"
          }, {
            field: "package"
          }],
          where: [{
            logic: "and",
            type: "=",
            args: [{
              field: "package"
            }, {
              value: pack
            }]
          }, {
            logic: "and",
            type: "=",
            args: [{
              field: "name"
            }, {
              value: name
            }]
          }]
        };
        var queryOptions = fcf.append({}, a_options, {
          query: query
        });
        return fcf.actions().exec(function (a_act) {
          self.getStorage().query(queryOptions, function (a_error, a_data) {
            if (a_error) {
              a_cb(a_error, result);
              a_act.error(a_error);
              return;
            }

            if (a_data[0].length) {
              result = fcf.strToObject(a_data[0][0].value);
            }

            if (a_cb) a_cb(undefined, result);
            a_act.complete(result);
          });
        });
      };

      this.updateSystemVariables = function (a_objectVariables, a_options, a_cb) {
        if (typeof a_options === "function") {
          a_cb = a_options;
          a_options = {};
        }

        if (!a_options) a_options = {};
        var result = {};
        var queries = [];

        for (var varName in a_objectVariables) {
          var query = {
            type: "update",
            from: "fcf_variables",
            values: [],
            where: []
          };
          var pos = varName.indexOf(":");
          var pack = pos != -1 ? varName.substr(0, pos) : "";
          var name = pos != -1 ? varName.substr(pos + 1) : varName;
          query.values.push({
            field: "value",
            value: JSON.stringify(a_objectVariables[varName])
          });
          query.where.push({
            logic: "or",
            type: "block",
            args: [{
              logic: "and",
              type: "=",
              args: [{
                field: "package"
              }, {
                value: pack
              }]
            }, {
              logic: "and",
              type: "=",
              args: [{
                field: "name"
              }, {
                value: name
              }]
            }]
          });
          queries.push(query);
        }

        var queryOptions = fcf.append({}, a_options, {
          query: queries
        });
        return self.getStorage().query(queryOptions);
      };

      this.getRouter = function () {
        this._router.update();

        return this._router;
      };

      this.getThemes = function () {
        return this._themes;
      };

      this.getStorage = function () {
        return this._storage;
      };

      this.getProjections = function () {
        return this._projections;
      };

      this.getRender = function () {
        return this._render;
      };

      this.getEventChannel = function () {
        return this._eventChannel;
      };

      this.getConfiguration = function () {
        return this._configuration;
      };

      this.appendPackages = function (a_packageNames) {
        if (!Array.isArray(a_packageNames)) return;

        for (var i = 0; i < a_packageNames.length; ++i) {
          this.appendPackage(a_packageNames[i]);
        }
      };

      this.appendPackage = function (a_packageName) {
        var path = "/fcfpackages/" + a_packageName + "/" + a_packageName + ".package";
        fcf.load({
          path: path,
          async: false,
          onResult: function onResult(a_error, a_data) {
            if (a_error) {
              fcf.log.err("FCF", a_error.message, a_error);
              return;
            }

            var info = fcf.scriptExecutor.parse(a_data, {}, path, 0);

            self._configuration.appendPackageInfo(a_packageName, info);
          }
        });
      };

      this.appendPackageRawObject = function (a_packageName, a_packageObject) {
        self._configuration.appendPackageInfo(a_packageName, a_packageObject);
      };

      this.appendThemes = function (a_themeNames) {
        if (!Array.isArray(a_themeNames)) return;

        for (var i = 0; i < a_themeNames.length; ++i) {
          this.appendTheme(a_themeNames[i]);
        }
      };

      this.appendTheme = function (a_themeName) {
        var path = "/fcfpackages/" + a_themeName + "/" + a_themeName + ".theme";
        fcf.load({
          path: path,
          async: false,
          onResult: function onResult(a_error, a_data) {
            if (a_error) {
              fcf.log.err("FCF", a_error.message, a_error);
              return;
            }

            var info = fcf.scriptExecutor.parse(a_data, {}, path, 0);
            var theme = new Theme({
              package: a_themeName,
              info: info,
              configuration: self._configuration
            });
            fcf.actions(theme.initialize()).then(function () {
              self._themes.attachTheme(a_themeName, theme);
            });
          }
        });
      };

      this.appendThemeRawObject = function (a_themeName, a_object) {
        var theme = new Theme({
          package: a_themeName,
          info: a_object,
          configuration: self._configuration
        });
        fcf.actions(theme.initialize()).then(function () {
          self._themes.attachTheme(a_themeName, theme);
        });
      };

      this.getLocalData = function () {
        return this._localData;
      };

      this.getInheritanceModes = function () {
        return this._configuration.getConfiguration().inheritanceModes;
      };

      this.delayedUpdate = function () {
        if (this._delayedUpdate) return;
        this._delayedUpdate = true;

        function clDelayedUpdate() {
          if (self._lastURL != window.location.href) {
            self._lastURL = window.location.href;
            setTimeout(clDelayedUpdate, 0);
          } else {
            self._delayedUpdate = false;
            self.update();
          }
        }

        setTimeout(clDelayedUpdate, 0);
      };

      this.delayedReload = function () {
        function clDelayedUpdate() {
          if (self._lastURL != window.location.href) {
            self._lastURL = window.location.href;
            setTimeout(clDelayedUpdate, 0);
          } else {
            window.location.reload(false);
          }
        }

        setTimeout(clDelayedUpdate, 0);
      };

      this.update = function () {
        this.getRouter().getRouteInfo().update({
          url: window.location.href
        });

        function clUpdateWrapper(a_id) {
          var wrapper = fcf.NDetails._wrappers[a_id];
          var originArgs = self.getLocalData().getSourceObject(a_id);
          var needUpdate = false;

          for (var key in originArgs) {
            var originItem = originArgs[key];

            if (fcf.isArg(originItem) && originItem.followRoute) {
              wrapper.cleanTemplateData(key);
              needUpdate = true;
            }
          }

          if (needUpdate) wrapper.refresh();
          return needUpdate;
        }

        function clEachProcess(a_wrapper) {
          var childs = a_wrapper.getChilds();

          for (var i = 0; i < childs.length; ++i) {
            if (!clUpdateWrapper(childs[i].getId())) {
              clEachProcess(childs[i]);
            }
          }
        }

        var rootElements = fcf.select(":not([fcfparent])[fcftemplate]");

        for (var i = 0; i < rootElements.length; ++i) {
          var wrapper = fcf.getWrapper(rootElements[i]);
          if (!wrapper) return;

          if (!clUpdateWrapper(wrapper.getId())) {
            clEachProcess(wrapper);
          }
        }
      };
    };

    fcf.NClient.application = new NClient.Application();
    fcf.application = fcf.NClient.application;
    return fcf.NClient.application;
  }
});
fcf.module({
  name: "fcf:NRender/Wrapper.js",
  module: function module() {
    var NRender = fcf.prepareObject(fcf, "NRender");
    var stUpdatableWrappers = {};
    var stUpdateCounter = 0;

    function stUpdateWrapper(a_info) {
      ++stUpdateCounter;
      var updateCounterLast = stUpdateCounter;
      stUpdatableWrappers[a_info.id] = a_info;

      function clUpdate() {
        if (updateCounterLast != stUpdateCounter) {
          updateCounterLast = stUpdateCounter;
          setTimeout(clUpdate, 1);
          return;
        }

        var wrappers = stUpdatableWrappers;
        stUpdatableWrappers = {};
        var rm = {};

        function clFilter(a_wrapper) {
          var chlids = a_wrapper.getChilds();

          for (var k in chlids) {
            var id = chlids[k].getId();
            if (id in wrappers) rm[id] = true;
            clFilter(chlids[k]);
          }
        }

        for (var id in wrappers) {
          var wrapper = fcf.getWrapper(id);

          if (!wrapper) {
            rm[id] = true;
            continue;
          }

          clFilter(wrapper);
        }

        for (var id in rm) {
          delete wrappers[id];
        }

        updateCounterLast = 0;

        function clFillExternalRef(a_dst, a_rootId, a_id) {
          var srcArgs = fcf.application.getLocalData().getSourceObject(a_id);

          if (srcArgs) {
            for (var key in srcArgs) {
              if (!fcf.isArg(srcArgs[key]) || srcArgs[key].type !== "reference") continue;
              var objectValues = fcf.application.getLocalData().getObject(a_id);
              var parentWrapper = fcf.getWrapper(a_id).getParent();
              var refParentObjectValues = parentWrapper ? fcf.application.getLocalData().getObject(parentWrapper.getId()) : undefined;
              var refId = fcf.tokenize(srcArgs[key].id, {
                args: objectValues,
                parent: refParentObjectValues
              });
              var refArg = fcf.tokenize(srcArgs[key].arg, {
                args: objectValues,
                parent: refParentObjectValues
              });
              var isInner = fcf.getWrapper(a_rootId).select("[id=" + refId + "]").length != 0;
              if (isInner) continue;
              if (!a_dst[refId]) a_dst[refId] = {};
              var refObjectValues = fcf.application.getLocalData().getObject(refId);
              var refData = fcf.resolveEx(refObjectValues, refArg);
              var refDst = fcf.resolveEx(a_dst[refId], refArg, true);

              if (refData.object == undefined) {
                refDst.object[refDst.key] = undefined;
              } else {
                refDst.object[refDst.key] = refData.object[refData.key];
              }
            }
          }
        }

        fcf.each(wrappers, function (rootId, info) {
          var externalRefValues = {};

          if (info.restoreState) {
            var modifyChildArgs = {
              childs: {},
              args: {}
            };
            var wrapper = fcf.getWrapper(rootId);

            if (wrapper) {
              clFillExternalRef(externalRefValues, rootId, rootId);
              var childs = wrapper.getChilds();

              function clFillChilds(a_wrapper, a_modifyChildArgs) {
                var fcfSaveChildsState = a_wrapper.getArg("fcfSaveChildsState");
                if (fcfSaveChildsState === undefined) fcfSaveChildsState = true;

                if (fcfSaveChildsState == false) {
                  return;
                }

                fcf.each(a_wrapper.getChilds(), function (a_key, a_child) {
                  var fcfCallPosition = a_child.getArg("fcfCP");
                  var id = a_child.getId();
                  var modifyKeys = fcf.application.getLocalData().getModifyKeys(id);
                  var args = {};
                  clFillExternalRef(externalRefValues, rootId, id);
                  var sources = fcf.application.getLocalData().getSourceObject(id);

                  for (var key in sources) {
                    if (modifyKeys && key in modifyKeys) args[key] = sources[key];
                  }

                  for (var key in modifyKeys) {
                    var srcArg = fcf.append({}, fcf.application.getLocalData().getSourceObject(id));
                    if (fcf.isArg(srcArg[key]) && srcArg[key].type == "reference") continue;
                    if (fcf.isArg(srcArg[key]) && srcArg[key].type != "programmable" && srcArg[key].important) continue;
                    args[key] = a_child.getArg(key);
                  }

                  args["[\"fcfId\"]"] = a_child.getId();
                  var fcfevntid = a_child.getDomElement().getAttribute("fcfevntid");
                  if (fcfevntid) args["[\"fcfEvntid\"]"] = fcfevntid;
                  a_modifyChildArgs.childs[fcfCallPosition] = {
                    childs: {},
                    args: args
                  };
                  clFillChilds(a_child, a_modifyChildArgs.childs[fcfCallPosition]);
                });
              }

              clFillChilds(wrapper, modifyChildArgs);
              info.args.fcfChildsArgs = modifyChildArgs;
            }
          } else {
            function clProcessChilds(a_wrapper) {
              clFillExternalRef(externalRefValues, rootId, a_wrapper.getId());
              fcf.each(a_wrapper.getChilds(), function (a_key, a_child) {
                clFillExternalRef(externalRefValues, rootId, a_child.getId());
              });
            }

            var wrapper = fcf.getWrapper(rootId);

            if (wrapper) {
              clProcessChilds(wrapper);
            }
          }

          fcf.application.render({
            template: info.template,
            theme: info.theme,
            owner: false,
            args: info.args,
            update: info.update,
            wrapper: info.wrapper,
            externalArgs: externalRefValues,
            onResult: function onResult(a_error, a_template) {
              info.cb(a_error, a_template, true);
            }
          });
        });
      }

      setTimeout(clUpdate, 0);
    }

    var stReferences = {};

    function stAttachReferences(a_wrapper) {
      var id = a_wrapper.getId();
      var srcArgs = fcf.application.getLocalData().getSourceObject(id);

      for (name in srcArgs) {
        var arg = srcArgs[name];

        if (fcf.isArg(arg) && arg.type == "reference") {
          if (arg.id.indexOf("${{") !== -1 || arg.id.indexOf("@{{") !== -1 || arg.arg.indexOf("${{") !== -1 || arg.arg.indexOf("@{{") !== -1) arg = fcf.tokenize(arg, {
            args: fcf.application.getLocalData().getObject(a_wrapper._id),
            route: fcf.getContext().get("route")
          });
          var argPath = fcf.normalizeObjectAddress(arg.arg);
          var argName = fcf.normalizeObjectAddress(fcf.parseObjectAddress(arg.arg)[0]);
          if (!stReferences[arg.id]) stReferences[arg.id] = {};
          if (!stReferences[arg.id][argName]) stReferences[arg.id][argName] = {};
          if (!stReferences[arg.id][argName][id]) stReferences[arg.id][argName][id] = {};
          stReferences[arg.id][argName][id][name] = argPath;
        }
      }
    }
    /**
    * @class fcf::NRender::Wrapper
    *
    *lng_en @brief <b>[client only]</b> Wrapper template on the client (module: fcf:NRender/Wrapper.js)
    *lng_en @details An instance of a class is bound to an HTML template to handle events and animate it :-)
    *
    *lng_ru @brief <b>[client only]</b> Врапер шаблона на клиенте (module: fcf:NRender/Wrapper.js)
    *lng_ru @details Экземпляр класса привязывается к HTML шаблону  для обработки событий и его оживления :-)
    **/


    var Wrapper = /*#__PURE__*/function () {
      "use strict";

      /**
      * @fn constructor(object a_initializeOptions)
      *
      *lng_en @brief Class constructor
      *lng_en @param object a_initializeOptions Initialization parameter
      *lng_en   - <b>DomElement</b>        domElement   Dom template element
      *lng_en   - <b>fcf::EventChannel</b> eventChannel the object of the message channel
      *lng_en   - <b>function</b> onReady(object a_error, fcf::NRender::Wrapper a_wrapper) The callback has completed initialization of the object
      *lng_en         - <b>object</b>                  a_error the error object is populated if an error occurs.
      *lng_en         - <b>fcf::NRender::Wrapper</b>   a_wrapper a pointer to itself
      *
      *lng_ru @brief Конструктор класа
      *lng_ru @param object a_initializeOptions Параметры инициализации
      *lng_ru   - <b>DomElement</b>        domElement   Dom элемент шаблона вафываыв
      *lng_ru   - <b>fcf::EventChannel</b> eventChannel объект канала сообщений
      *lng_ru   - <b>function</b> onReady(object a_error, fcf::NRender::Wrapper a_wrapper) Обратный вызов завершения инициализации объекта
      *lng_ru         - <b>object</b>                  a_error объект ошибки, заполняется если возникает ошибка.
      *lng_ru         - <b>fcf::NRender::Wrapper</b>   a_wrapper указатель на себя
      **/
      function Wrapper(a_initializeOptions, a_ignoreReg) {
        _classCallCheck(this, Wrapper);

        this._id = a_initializeOptions.domElement.getAttribute("id");
        this._setArgRecursion = false;
        this._initializeOptions = a_initializeOptions;
        this._callPositionsSetArg = {};
        if (!a_ignoreReg) fcf.NDetails._wrappers[this._id] = this;
      }
      /**
      * @fn void initialize()
      *
      *lng_en @brief Initializes an instance of an object
      *
      *lng_ru @brief Запускает инициализацию экземпляра объекта
      **/


      _createClass(Wrapper, [{
        key: "initialize",
        value: function initialize() {
          var self = this;
          fcf.liven(undefined, this._id, function (a_error) {
            if (a_error) {
              if (this._initializeOptions.onReady) this._initializeOptions.onReady(a_error, self);
              return;
            }

            self._initialize(function (a_error) {
              if (a_error) {
                if (this._initializeOptions.onReady) this._initializeOptions.onReady(a_error, self);
                return;
              }

              self._attachInnerEvents();

              self._attach(function (a_error) {
                if (a_error) {
                  if (this._initializeOptions.onReady) this._initializeOptions.onReady(a_error, self);
                  return;
                }

                stAttachReferences(self);
                if (self._initializeOptions.onReady) self._initializeOptions.onReady(a_error, self);
              });
            });
          });
        }
        /**
        * @fn void reattach(function a_cb)
        *
        *lng_en @brief Re-associates the object with the template
        *lng_en @param function a_cb(object a_error, fcf::NRender::Wrapper a_wrapper) Operation completion callback
        *lng_en         - <b>object</b>                  a_error the error object is populated if an error occurs.
        *lng_en         - <b>fcf::NRender::Wrapper</b>   a_wrapper a pointer to itself
        *
        *lng_ru @brief Выполняет повторное связывание объекта с шаблоном
        *lng_ru @param function a_cb(object a_error, fcf::NRender::Wrapper a_wrapper) Обратный вызов завершения  операции
        *lng_ru         - <b>object</b>                  a_error объект ошибки, заполняется если возникает ошибка.
        *lng_ru         - <b>fcf::NRender::Wrapper</b>   a_wrapper указатель на себя
        **/

      }, {
        key: "reattach",
        value: function reattach(a_cb) {
          var self = this;
          fcf.liven(undefined, this._id, function (a_error) {
            self._attachInnerEvents();

            self._attach(function (a_error) {
              a_cb(a_error, self);
            });
          });
        }
      }, {
        key: "getInitializeOptions",
        value: function getInitializeOptions() {
          return this._initializeOptions;
        }
      }, {
        key: "update",
        value: function update(a_cb) {
          var self = this;

          if (!this.getDomElement()) {
            if (a_cb) a_cb();
            return;
          }

          var alias = this.getDomElement().getAttribute("fcfalias");
          var template = this.getDomElement().getAttribute("fcftemplate");
          var parentId = this.getDomElement().getAttribute("fcfparent");
          if (parentId === null) parentId = undefined;
          var id = this.getDomElement().getAttribute("id");
          var args = fcf.append({}, fcf.application.getLocalData().getSourceObject(id));
          fcf.each(fcf.application.getLocalData().getModifyKeys(id), function (a_key) {
            var ptr = fcf.resolveEx(args, a_key, true);
            ptr.object[fcf.normalizeObjectAddress(ptr.key)] = fcf.application.getLocalData().getItem(id, a_key);
          });
          if (!fcf.empty(alias)) args.fcfAlias = alias;
          args.fcfId = id;
          args.fcfParent = parentId;
          if (this.getDomElement().getAttribute("fcfevntid")) args.fcfEvntid = this.getDomElement().getAttribute("fcfevntid");
          var updateInfo = {
            id: this.getId(),
            template: template,
            theme: this.getThemeName(),
            args: args,
            update: true,
            restoreState: true,
            wrapper: false,
            cb: function cb(a_error, a_template, a_rootCallback) {
              if (!a_rootCallback) return;

              if (a_template.state && a_template.state.args) {
                for (var id in a_template.state.args) {
                  fcf.application.getLocalData().setOriginObject(id, a_template.state.args[id]);
                  fcf.application.getLocalData().setObject(id, {});
                }
              }

              if (a_template.state && a_template.state.sources) {
                for (var id in a_template.state.sources) {
                  fcf.application.getLocalData().setSourceObject(id, a_template.state.sources[id]);
                }
              }

              var domElement = self.getDomElement();

              if (!domElement) {
                if (a_cb) a_cb(undefined, self);
                return;
              }

              domElement.outerHTML = a_template.content;
              fcf.liven(domElement, a_cb);
            }
          };
          stUpdateWrapper(updateInfo);
        }
      }, {
        key: "refresh",
        value: function refresh(a_cb) {
          var self = this;

          if (!this.getDomElement()) {
            if (a_cb) a_cb();
            return;
          }

          var alias = this.getDomElement().getAttribute("fcfalias");
          var template = this.getDomElement().getAttribute("fcftemplate");
          var parentId = this.getDomElement().getAttribute("fcfparent");
          if (parentId === null) parentId = undefined;
          var id = this.getDomElement().getAttribute("id");
          var args = fcf.application.getLocalData().getOriginSourceObject(id);
          if (!fcf.empty(alias)) args.fcfAlias = alias;
          args.fcfId = id;
          args.fcfParent = parentId;
          var updateInfo = {
            id: this.getId(),
            template: template,
            theme: this.getThemeName(),
            args: args,
            update: true,
            restoreState: false,
            wrapper: false,
            cb: function cb(a_error, a_template, a_rootCallback) {
              if (!a_rootCallback) return;

              if (a_template.state && a_template.state.args) {
                for (var id in a_template.state.args) {
                  fcf.application.getLocalData().setOriginObject(id, a_template.state.args[id]);
                  fcf.application.getLocalData().setObject(id, {});
                  fcf.application.getLocalData().resetSources();
                  fcf.application.getLocalData().clearModifyKeys(id);
                  var wrp = fcf.getWrapper(id);

                  if (wrp) {
                    var rwrp = new wrp.constructor(wrp.getInitializeOptions(), true);

                    for (var k in rwrp) {
                      if (k == "_id") continue;
                      wrp[k] = rwrp[k];
                    }
                  }
                }
              }

              if (a_template.state && a_template.state.sources) {
                for (var id in a_template.state.sources) {
                  fcf.application.getLocalData().setSourceObject(id, a_template.state.sources[id]);
                }
              }

              var element = self.getDomElement();
              element.outerHTML = a_template.content;
              fcf.liven(element, a_cb);
            }
          };
          stUpdateWrapper(updateInfo);
        }
      }, {
        key: "save",
        value: function save() {
          this.setArg("data", this.getData());
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (typeof this.onDestroy === "function") this.onDestroy();
          var de = this.getDomElement();
          de.parentElement.removeChild(this.getDomElement());
          delete stReferences[this.getId()];
          delete fcf.NDetails._wrappers[this.getId()];
        }
      }, {
        key: "render",
        value: function render(a_options) {
          var args = {
            '["fcfParent"]': this.getId()
          };
          if (typeof a_options.args === "object") for (var key in a_options.args) {
            args[fcf.normalizeObjectAddress(key)] = a_options.args[key];
          }
          var template = a_options.template.charAt(0) == "+" ? this.getDomElement().getAttribute("fcftemplate") + a_options.template : a_options.template;
          fcf.application.render({
            template: template,
            owner: a_options.owner,
            args: args,
            onResult: function onResult(a_error, a_template) {
              if (a_options.onResult) a_options.onResult(a_error, a_template);
            }
          });
        }
      }, {
        key: "getEventChannel",
        value: function getEventChannel() {
          return this._initializeOptions.eventChannel;
        }
      }, {
        key: "emit",
        value: function emit(a_event, a_exData) {
          if (typeof a_event == "string") {
            var event = document.createEvent('Event');
            event.initEvent(a_event, true, true);
            event.name = a_event;
            if (!event.type) event.type = a_event;
            a_event = event;
          }

          if (a_exData) fcf.append(a_event, a_exData);
          fcf.emitDomEvent(this.getActionDomElement(), a_event);
          return a_event;
        }
      }, {
        key: "send",
        value: function send(a_data, a_inputFiles, a_cb) {
          var self = this;
          return fcf.actions().exec(function (a_act) {
            var formData = new FormData();
            formData.append('data', JSON.stringify(a_data));
            formData.append('_fcfContext', JSON.stringify(fcf.getContext()));
            var filesAttributes = [];
            var counter = 0;
            fcf.each(a_inputFiles, function (k, input) {
              if (!input.files) return;

              for (var i = 0; i < input.files.length; ++i) {
                formData.append('files[' + counter++ + ']', input.files[i]);
                var attributes = {};
                fcf.each(input.attributes, function (k, attr) {
                  attributes[attr.name] = attr.value;
                });
                filesAttributes.push(attributes);
              }
            });
            formData.append('filesAttributes', JSON.stringify(filesAttributes));
            fcf.load({
              path: "@url:fcfReceive?template=" + encodeURIComponent(self.getTemplate()),
              post: formData,
              onResult: function onResult(a_error, a_response) {
                if (a_cb) a_cb(a_error, a_response);

                if (a_error) {
                  fcf.application.getEventChannel().send("error", {
                    error: a_error
                  });
                  a_act.error(a_error);
                } else {
                  a_act.complete(a_response);
                }
              }
            });
          });
        }
      }, {
        key: "getTemplate",
        value: function getTemplate() {
          return this.getDomElement().getAttribute("fcftemplate");
        }
      }, {
        key: "getId",
        value: function getId() {
          return this._id;
        }
      }, {
        key: "getAlias",
        value: function getAlias() {
          return this.getDomElement().getAttribute("fcfalias");
        }
      }, {
        key: "getDomElement",
        value: function getDomElement() {
          return document.getElementById(this._id);
        }
      }, {
        key: "getActionDomElement",
        value: function getActionDomElement() {
          return this.getDomElement();
        }
      }, {
        key: "getParent",
        value: function getParent() {
          if (!this.getDomElement()) return;
          var parentId = this.getDomElement().getAttribute("fcfparent");
          if (fcf.empty(parentId)) return;
          return fcf.getWrapper(parentId);
        }
      }, {
        key: "getChilds",
        value: function getChilds() {
          var domChilds = fcf.select(document.getElementById(this._id), "[fcfparent=" + this._id + "]");
          var result = [];

          for (var i = 0; i < domChilds.length; ++i) {
            var wrapper = fcf.NDetails._wrappers[domChilds[i].getAttribute("id")];

            if (wrapper) result.push(wrapper);
          }

          return result;
        }
      }, {
        key: "getFirstChild",
        value: function getFirstChild() {
          var domChilds = fcf.select(document.getElementById(this._id), "[fcfparent=" + this._id + "]");

          for (var i = 0; i < domChilds.length; ++i) {
            var wrapper = fcf.NDetails._wrappers[domChilds[i].getAttribute("id")];

            return wrapper;
          }

          return;
        }
      }, {
        key: "getChild",
        value: function getChild(a_alias) {
          var domChild = fcf.first(fcf.select(document.body, "[fcfparent=\"" + this._id + "\"][fcfalias=\"" + fcf.encodeHtml(a_alias) + "\"]"));
          if (!domChild) return;
          return fcf.NDetails._wrappers[domChild.getAttribute("id")];
        }
      }, {
        key: "select",
        value: function select(a_selector) {
          return fcf.select("[id=" + this.getId() + "] " + a_selector);
        }
      }, {
        key: "getWidthPx",
        value: function getWidthPx() {
          return document.getElementById(this.getId()).offsetWidth;
        }
      }, {
        key: "getHeightPx",
        value: function getHeightPx() {
          return document.getElementById(this.getId()).offsetHeight;
        }
      }, {
        key: "getLeftPx",
        value: function getLeftPx() {
          return this.getDomElement().getBoundingClientRect().left - document.body.getBoundingClientRect().left;
        }
      }, {
        key: "getTopPx",
        value: function getTopPx() {
          return this.getDomElement().getBoundingClientRect().top - document.body.getBoundingClientRect().top;
        }
      }, {
        key: "addDomListener",
        value: function addDomListener(a_eventName, a_func) {
          var element = this.getActionDomElement();
          if (!element) return;
          fcf.addDomListener(element, a_eventName, a_func);
        }
      }, {
        key: "addChildDomListener",
        value: function addChildDomListener(a_alias, a_eventName, a_func) {
          var element = this.getChild(a_alias);
          element.addDomListener(a_eventName, function (a_event) {
            a_func(a_event);
          });
        }
      }, {
        key: "cleanTemplateData",
        value: function cleanTemplateData(a_key) {
          fcf.application.getLocalData().cleanItem(this._id, a_key);
        }
      }, {
        key: "getFollowRouteArgs",
        value: function getFollowRouteArgs(a_key) {}
      }, {
        key: "getCurrentData",
        value: function getCurrentData() {
          return this.getActionDomElement().value;
        }
      }, {
        key: "getData",
        value: function getData() {
          this.getArg("[\"value\"]");
        }
      }, {
        key: "setData",
        value: function setData(a_value) {
          this.setArg("[\"value\"]", a_value);
        }
      }, {
        key: "getArg",
        value: function getArg(a_key) {
          var source = fcf.application.getLocalData().getSourceItem(this._id, a_key);

          if (fcf.isArg(source) && source.type === "reference") {
            var args = {
              args: fcf.application.getLocalData().getObject(this._id)
            };
            source = fcf.tokenize(source, args);
            var dataOwner = fcf.getWrapper(source.id);
            if (!source) return fcf.application.getLocalData().getItem(this._id, a_key);
            return dataOwner.getArg(source.arg);
          } else {
            return fcf.application.getLocalData().getItem(this._id, a_key);
          }
        }
      }, {
        key: "getArgs",
        value: function getArgs() {
          return fcf.application.getLocalData().getObject(this._id);
        }
      }, {
        key: "setArg",
        value: function setArg(a_key, a_value, a_ignoreCallbacks) {
          var stack = new Error().stack;

          if (stack === undefined) {
            try {
              throw new Error();
            } catch (e) {
              stack = e.stack;
            }
          }

          var pos = stack.indexOf("\n", 0);
          pos = stack.indexOf("\n", pos + 1);
          var posEnd = stack.indexOf("\n", pos + 1);
          var callPosition = fcf.trim(stack.substr(pos, posEnd - pos));
          a_key = fcf.normalizeObjectAddress(a_key);

          this._setArg(a_key, a_value, a_ignoreCallbacks, callPosition);
        }
      }, {
        key: "_setArg",
        value: function _setArg(a_key, a_value, a_ignoreCallbacks, callPosition) {
          var self = this;
          if (callPosition in this._callPositionsSetArg) return;
          this._callPositionsSetArg[callPosition] = true;
          fcf.application.getLocalData().setItem(this._id, a_key, a_value);
          if (a_ignoreCallbacks) return;
          var eventMap = {};

          var clGetArgInfo = function clGetArgInfo(a_id, a_key) {
            var parts = fcf.parseObjectAddress(a_key);
            var name = "";
            var suffix = "";
            var source = undefined;

            for (var i = 0; i < parts.length; ++i) {
              name = "";
              var size = parts.length - i;

              for (var j = 0; j < size; ++j) {
                name += '["' + parts[j] + '"]';
              }

              source = fcf.application.getLocalData().getSourceItem(a_id, name);
              if (source === undefined) continue;
              suffix = "";

              for (var j = size; j < parts.length; ++j) {
                suffix += '["' + parts[j] + '"]';
              }

              break;
            }

            if (fcf.isArg(source) && source.type == "reference") {
              if (source.id.indexOf("${{") !== -1 || source.id.indexOf("@{{") !== -1 || source.arg.indexOf("${{") !== -1 || source.arg.indexOf("@{{") !== -1) {
                source = fcf.tokenize(source, {
                  args: fcf.application.getLocalData().getObject(a_id),
                  route: fcf.getContext().get("route")
                });
              }
            }

            return {
              path: fcf.normalizeObjectAddress(a_key),
              arg: name,
              suffix: suffix,
              id: a_id,
              source: source,
              requestPath: ""
            };
          };

          var clProcessLink = function clProcessLink(a_id, a_key, a_value, a_req, a_eventMap, a_protectDublicattes, a_isRoot, a_upDirection) {
            a_key = fcf.normalizeObjectAddress(a_key);
            if (a_req[a_id + " -> " + a_key]) return;
            a_req[a_id + " -> " + a_key] = true;
            var argInfo = clGetArgInfo(a_id, a_key);

            if (!a_protectDublicattes[a_id + argInfo.arg] || a_protectDublicattes[a_id + argInfo.arg] < argInfo.suffix.length) {
              a_protectDublicattes[a_id + argInfo.arg] = argInfo.suffix.length;
              a_eventMap[a_id + "->" + a_key] = {
                id: a_id,
                arg: argInfo.arg,
                suffix: argInfo.suffix,
                value: fcf.application.getLocalData().getItem(a_id, argInfo.arg)
              };
            }

            if (argInfo.source === undefined) return; //going up the graph

            if (fcf.isArg(argInfo.source) && argInfo.source.type == "reference") {
              clProcessLink(argInfo.source.id, argInfo.source.arg + argInfo.suffix, a_value, a_req, a_eventMap, a_protectDublicattes, false, true);
            } //going down the graph


            if (stReferences[a_id] && stReferences[a_id][argInfo.arg]) {
              var refsInfo = stReferences[a_id][argInfo.arg];

              for (var childId in refsInfo) {
                for (var childArgPath in refsInfo[childId]) {
                  var refChlidsPath = refsInfo[childId][childArgPath];

                  if (argInfo.path.indexOf(refChlidsPath) == 0) {
                    var child = fcf.application.getLocalData().getSourceItem(childId, childArgPath);
                    var childParts = fcf.parseObjectAddress(child.arg);
                    childParts.shift();
                    var ownerParts = fcf.parseObjectAddress(argInfo.suffix);
                    var newSuffixParts = [];
                    var fullCopy = true;

                    for (var _i3 = 0; _i3 < ownerParts.length; ++_i3) {
                      if (_i3 >= childParts.length) newSuffixParts.push(ownerParts[_i3]);
                    }

                    var newSuffix = "";

                    for (var i = 0; i < newSuffixParts.length; ++i) {
                      newSuffix += "[\"" + newSuffixParts[i] + "\"]";
                    }

                    var _value = fcf.application.getLocalData().getItem(childId, childArgPath + newSuffix);

                    clProcessLink(childId, childArgPath + newSuffix, _value, a_req, a_eventMap, a_protectDublicattes, false, false);
                  }
                }
              }
            }
          }; //if (!this._setArgRecursion) {


          this._setArgRecursion = true;
          clProcessLink(this._id, a_key, a_value, {}, eventMap, {}, true, true);
          a_key = fcf.normalizeObjectAddress(a_key);

          for (var i in eventMap) {
            var id = eventMap[i].id;
            var eventInfo = eventMap[i];
            var wrp = fcf.getWrapper(id);
            if (!wrp) continue;

            try {
              if (wrp.onArg) wrp.onArg(eventInfo.arg, eventInfo.value, eventInfo.suffix);
            } catch (e) {
              fcf.error("Wrapper", e, false);
            }

            var simpleArg = "";

            for (var _i4 = 0; _i4 < eventInfo.arg.length; ++_i4) {
              if (eventInfo.arg[_i4] != "\"" && eventInfo.arg[_i4] != "[" && eventInfo.arg[_i4] != "]") simpleArg += eventInfo.arg[_i4];
            }

            var method = "onArg" + simpleArg.charAt(0).toUpperCase() + simpleArg.slice(1);

            try {
              if (wrp[method]) wrp[method](eventInfo.value, eventInfo.suffix);
            } catch (e) {
              fcf.error("Wrapper", e, false);
            }

            var originArg = fcf.application.getLocalData().getSourceItem(id, eventMap[i].arg);

            if (fcf.isArg(originArg) && originArg.followRoute) {
              if (originArg.followRoute == "reload" || originArg.followRoute == "soft" || originArg.followRoute == "set") {
                var args = fcf.getRouteVariablesBySource(originArg);
                var value = this.getArg(a_key);

                for (var i = 0; i < args.length; ++i) {
                  fcf.application.getRouter().setArg(args[i], value);
                }
              }

              if (originArg.followRoute == "reload") fcf.application.delayedReload();else if (originArg.followRoute == "soft") fcf.application.delayedUpdate();
            }
          }

          this._setArgRecursion = false;
          this._callPositionsSetArg = {}; //}
        }
      }, {
        key: "getChildArg",
        value: function getChildArg(a_alias, a_argName) {
          var element = this.getChild(a_alias);
          return element.getData();
        }
      }, {
        key: "validate",
        value: function validate() {
          var resultErrors = [];
          var childs = this.getChilds();

          for (var i = 0; i < childs.length; ++i) {
            var suberrors = childs[i].validate();
            resultErrors = fcf.append(resultErrors, suberrors);
          }

          return resultErrors;
        }
      }, {
        key: "showErrors",
        value: function showErrors(a_errors) {
          var childs = this.getChilds();

          for (var i = 0; i < childs.length; ++i) {
            var childId = childs[i].getId();
            var childErrors = [];

            for (var j = 0; j < a_errors.length; ++j) {
              if (fcf.find(a_errors[j].id, childId) !== undefined) childErrors.push(a_errors[j]);
            }

            if (!fcf.empty(childErrors)) childs[i].showErrors(childErrors);
          }
        }
      }, {
        key: "_initialize",
        value: function _initialize(a_cb) {
          a_cb();
        }
      }, {
        key: "_attach",
        value: function _attach(a_cb) {
          if (typeof this.onAttach === "function") {
            var res = this.onAttach();

            if (res instanceof fcf.Actions) {
              res.then(function () {
                a_cb();
              });
            } else {
              a_cb();
            }
          } else {
            a_cb();
          }
        }
      }, {
        key: "getThemeName",
        value: function getThemeName() {
          return fcf.application.getThemes().getDefaultThemeName();
        }
      }, {
        key: "getTheme",
        value: function getTheme() {
          return fcf.application.getThemes().getTheme(this.getThemeName());
        }
      }]);

      return Wrapper;
    }();

    ;

    Wrapper.prototype._attachInnerEvents = function () {
      var self = this; // attach events by attributes

      function clAttach(a_element) {
        var fcfEvents = {};

        for (var _i5 = 0; _i5 < a_element.attributes.length; ++_i5) {
          if (a_element.attributes[_i5].name.toLowerCase().indexOf("fcfevent") == 0) {
            fcfEvents[a_element.attributes[_i5].name.substr(8)] = a_element.attributes[_i5].value;
          }
        }

        ;

        var _loop = function _loop(_eventName) {
          var eventCode = fcfEvents[_eventName];
          var options = {
            wrapper: self,
            parent: self.getParent()
          };

          (function (options, eventCode) {
            fcf.addDomListener(a_element, _eventName, function (event) {
              with (options) {
                return eval(eventCode);
              }
            });
          })(options, eventCode);
        };

        for (var _eventName in fcfEvents) {
          _loop(_eventName);
        }

        for (var i = 0; i < a_element.children.length; ++i) {
          if (a_element.children[i].getAttribute("fcftemplate")) continue;
          var r = clAttach(a_element.children[i]);
        }
      }

      clAttach(this.getDomElement()); // attach events by arguments

      var templateData = this.getArgs();

      for (var key in templateData) {
        if (typeof key !== "string") continue;
        if (key.indexOf("fcfEvent") !== 0) continue;
        var eventName = key.substr(8);
        eventName = eventName[0].toLowerCase() + eventName.substr(1);
        var eventCode = templateData[key];
        var options = {
          wrapper: self,
          parent: self.getParent()
        };

        (function (eventName, eventCode, options) {
          self.addDomListener(eventName, function (event) {
            with (options) {
              return eval(eventCode);
            }
            return __result;
          });
        })(eventName, eventCode, options);
      }
    };

    NRender.Wrapper = Wrapper;
    return NRender.Wrapper;
  }
});